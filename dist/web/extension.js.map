{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://keystroke-recording/./src/await_controller.js","webpack://keystroke-recording/./src/command_sequence.js","webpack://keystroke-recording/./src/cursor_motion_detector.js","webpack://keystroke-recording/./src/end_of_file_detector.js","webpack://keystroke-recording/./src/extension.js","webpack://keystroke-recording/./src/helper_context.js","webpack://keystroke-recording/./src/internal_commands.js","webpack://keystroke-recording/./src/keyboard_macro.js","webpack://keystroke-recording/./src/reentrant_guard.js","webpack://keystroke-recording/./src/typing_detector.js","webpack://keystroke-recording/./src/util.js","webpack://keystroke-recording/external commonjs \"vscode\"","webpack://keystroke-recording/webpack/bootstrap","webpack://keystroke-recording/webpack/startup"],"sourcesContent":["'use strict';\nconst vscode = require('vscode');\n\nconst AwaitController = function() {\n    const DefaultTimeout = 300;\n    const documentChanged = [];\n    const selectionChanged = [];\n\n    const processDocumentChangeEvent = function() {\n        const notifiers = Array.from(documentChanged);\n        documentChanged.length = 0;\n        for (let i = 0; i < notifiers.length; i++) {\n            notifiers[i]();\n        }\n    };\n    const processSelectionChangeEvent = function() {\n        const notifiers = Array.from(selectionChanged);\n        selectionChanged.length = 0;\n        for (let i = 0; i < notifiers.length; i++) {\n            notifiers[i]();\n        }\n    };\n    const sleep = msec => new Promise(resolve => setTimeout(resolve, msec));\n    const waitForClipboardChange = async function(timeout) {\n        const last = await vscode.env.clipboard.readText();\n        let quit = false;\n        setTimeout(() => { quit = true; }, timeout);\n        while (!quit) {\n            await sleep(5);\n            const current = await vscode.env.clipboard.readText();\n            if (current !== last) {\n                return;\n            }\n        }\n        throw 'timeout';\n    };\n\n    const waitFor = function(awaitOption, timeout = DefaultTimeout) {\n        const awaitList = awaitOption.split(' ');\n        const promises = [];\n        let resolveFunc = null;\n        let expectedEventCount = 0;\n        const doneOne = function() {\n            expectedEventCount -= 1;\n            if (expectedEventCount == 0) {\n                resolveFunc();\n            }\n        };\n        for (let i = 0; i < awaitList.length; i++) {\n            const e = awaitList[i];\n            if (e === 'document') {\n                expectedEventCount += 1;\n                documentChanged.push(doneOne);\n            } else if (e === 'selection') {\n                expectedEventCount += 1;\n                selectionChanged.push(doneOne);\n            } else if (e === 'clipboard') {\n                promises.push(waitForClipboardChange(timeout));\n            } else if (e !== '') {\n                console.error('Error (kb-macro): Unknown args.await parameter \"' + e + '\"');\n            }\n        }\n        if (expectedEventCount !== 0) {\n            promises.push(new Promise((resolve, reject) => {\n                resolveFunc = resolve;\n                setTimeout(() => {\n                    if (0 < expectedEventCount) {\n                        expectedEventCount = 0;\n                        reject();\n                    }\n                }, timeout);\n            }));\n        }\n        if (promises.length === 0) {\n            return Promise.resolve(null);\n        } else {\n            return Promise.all(promises);\n        }\n    };\n\n    return {\n        processDocumentChangeEvent,\n        processSelectionChangeEvent,\n        waitFor\n    };\n};\n\nmodule.exports = { AwaitController };\n","'use strict';\n\nconst CommandSequence = function() {\n    const sequence = [];\n\n    const clear = function() {\n        sequence.length = 0;\n    };\n    const push = function(commandSpec) {\n        commandSpec['timestamp']=new Date().toISOString();\n        sequence.push(commandSpec);\n    };\n    const optimize = function() {\n        for (let i = 0; i < sequence.length; i++) {\n            // Remove a pair of cursor movement that results nothing\n            if (i + 1 < sequence.length &&\n                sequence[i].command === '$moveCursor' &&\n                sequence[i + 1].command === '$moveCursor') {\n                const args1 = sequence[i].args || {};\n                const args2 = sequence[i + 1].args || {};\n                const characterDelta1 = args1.characterDelta || 0;\n                const characterDelta2 = args2.characterDelta || 0;\n                const lineDelta1 = args1.lineDelta || 0;\n                const lineDelta2 = args2.lineDelta || 0;\n                const selectionLength2 = args2.selectionLength || 0;\n                const groupSize1 = args1.groupSize || 1;\n                const groupSize2 = args2.groupSize || 1;\n                if (lineDelta1 === 0 &&\n                    lineDelta2 === 0 &&\n                    selectionLength2 === 0 &&\n                    groupSize1 === 1 &&\n                    groupSize2 === 1 &&\n                    characterDelta1 + characterDelta2 === 0) {\n                    sequence.splice(i, 2);\n                    i--;\n                    continue;\n                }\n            }\n            // Combine cursor motion to the left and successive typing with deleting to the right\n            if (i + 1 < sequence.length &&\n                sequence[i].command === '$moveCursor' &&\n                sequence[i + 1].command === '$type') {\n                const args1 = sequence[i].args || {};\n                const args2 = sequence[i + 1].args || {};\n                const characterDelta1 = args1.characterDelta || 0;\n                const lineDelta1 = args1.lineDelta || 0;\n                const selectionLength1 = args1.selectionLength || 0;\n                const groupSize1 = args1.groupSize || 1;\n                const deleteLeft2 = args2.deleteLeft || 0;\n                const deleteRight2 = args2.deleteRight || 0;\n                if (lineDelta1 === 0 &&\n                    selectionLength1 === 0 &&\n                    groupSize1 === 1 &&\n                    characterDelta1 < 0 &&\n                    characterDelta1 + deleteRight2 === 0) {\n                    sequence[i + 1].args.deleteLeft = deleteLeft2 + deleteRight2;\n                    delete sequence[i + 1].args.deleteRight;\n                    sequence.splice(i, 1);\n                    i--;\n                    continue;\n                }\n            }\n            // Concatenate consecutive direct typing\n            if (0 < i &&\n                sequence[i - 1].command === '$type' &&\n                sequence[i].command === '$type'\n            ) {\n                const args1 = sequence[i - 1].args || {};\n                const args2 = sequence[i].args || {};\n                const text1 = args1.text || '';\n                const text2 = args2.text || '';\n                const deleteLeft2 = args2.deleteLeft || 0;\n                const deleteRight2 = args2.deleteRight || 0;\n                if (text1.length >= deleteLeft2 &&\n                    deleteRight2 === 0) {\n                    const text = text1.substr(0, text1.length - deleteLeft2) + text2;\n                    sequence[i - 1].args.text = text;\n                    sequence.splice(i, 1);\n                    i--;\n                    continue;\n                }\n            }\n        }\n    };\n\n    return {\n        clear,\n        push,\n        optimize,\n        get: function() { return sequence; }\n    };\n};\n\nmodule.exports = { CommandSequence };\n","'use strict';\nconst util = require('./util.js');\n\nconst CursorMotionDetector = function() {\n    const CursorMotionType = {\n        Trailing: 0,\n        Alone: 1\n    };\n    let onDetectCursorMotionCallback = null;\n    let enabled = false;\n    let aloneEnabled = false;\n    let lastSelections = null;\n    let lastTextEditor = null;\n    const predictions = [];\n    let textEditorForPredictions = null;\n\n    const onDetectCursorMotion = function(callback) {\n        onDetectCursorMotionCallback = callback;\n    };\n    const notifyDetectedMotion = function(type, motion) {\n        if (onDetectCursorMotionCallback) {\n            onDetectCursorMotionCallback(type, motion);\n        }\n    };\n\n    // const selectionsToString = function(selections) {\n    //     return JSON.stringify(Array.from(selections).map(sel => {\n    //         const { anchor, active } = sel;\n    //         const { line: l1, character: c1 } = anchor;\n    //         const { line: l2, character: c2 } = active;\n    //         if (l1 === l2 && c1 === c2) {\n    //             return [ l1, c1 ];\n    //         } else {\n    //             return [ l1, c1, l2, c2 ];\n    //         }\n    //     }));\n    // };\n\n    const start = function(textEditor) {\n        lastSelections = textEditor ? textEditor.selections : null;\n        lastTextEditor = textEditor || null;\n        predictions.length = 0;\n        textEditorForPredictions = lastTextEditor;\n        enabled = true;\n    };\n    const stop = function() {\n        enabled = false;\n    };\n    const setAloneEnabled = function(enabled) {\n        aloneEnabled = enabled;\n    };\n    const setPrediction = function(textEditor, expected) {\n        if (textEditorForPredictions !== textEditor) {\n            predictions.length = 0;\n            textEditorForPredictions = textEditor;\n        }\n        predictions.push(expected);\n        // console.log('pred', selectionsToString(expected));\n    };\n    const getPrediction = function(textEditor) {\n        if (textEditorForPredictions === textEditor) {\n            return predictions.length === 0 ? null : predictions[predictions.length - 1];\n        } else {\n            return null;\n        }\n    };\n    const calculateMotion = function(document, target, base) {\n        const basePos = base.start;\n        if (target.start.line === basePos.line &&\n            target.start.line === target.end.line &&\n            target.start.character !== basePos.character) {\n            const characterDelta = target.start.character - basePos.character;\n            const selectionLength = target.end.character - target.start.character;\n            if (selectionLength === 0) {\n                return { characterDelta };\n            } else {\n                return { characterDelta, selectionLength };\n            }\n        } else if (target.start.line !== basePos.line &&\n            target.start.line === target.end.line) {\n            const lineDelta = target.start.line - basePos.line;\n            if (lineDelta < 0) {\n                const lineLength = document.lineAt(target.start.line).text.length;\n                const characterDelta = target.start.character - lineLength;\n                const selectionLength = target.end.character - target.start.character;\n                if (selectionLength === 0) {\n                    return { lineDelta, characterDelta };\n                } else {\n                    return { lineDelta, characterDelta, selectionLength };\n                }\n            } else {\n                const characterDelta = target.start.character;\n                const selectionLength = target.end.character - target.start.character;\n                if (selectionLength === 0) {\n                    return { lineDelta, characterDelta };\n                } else {\n                    return { lineDelta, characterDelta, selectionLength };\n                }\n            }\n        }\n    };\n    const equalsMotion = function(a, b) {\n        return (\n            a && b &&\n            a.lineDelta === b.lineDelta &&\n            a.characterDelta === b.characterDelta &&\n            a.selectionLength === b.selectionLength\n        );\n    };\n\n    // Detect motion where each cursor moves with the same set of parameters\n    const detectUniformMotion = function(document, target, base) {\n        const motion = calculateMotion(document, target[0], base[0]);\n        if (!motion) {\n            return;\n        }\n        for (let i = 1; i < target.length; i++) {\n            if (!equalsMotion(motion, calculateMotion(document, target[i], base[i]))) {\n                return;\n            }\n        }\n        // found uniform motion\n        return motion;\n    };\n    // Detect motion where each cursor splits into n cursors in the same ways\n    const detectSplittingMotion = function(document, target, base, n) {\n        const motions = [];\n        for (let j = 0; j < n; j++) {\n            motions[j] = calculateMotion(document, target[j], base[0]);\n            if (!motions[j]) {\n                return;\n            }\n            if (motions[j].selectionLength !== motions[0].selectionLength) {\n                return;\n            }\n        }\n        for (let dest = n; dest < target.length; dest++) {\n            const src = Math.floor(dest / n);\n            const m = calculateMotion(document, target[dest], base[src]);\n            if (!equalsMotion(m, motions[dest % n])) {\n                return;\n            }\n        }\n        // found uniform splitting motion\n        const motion = {\n            characterDelta: motions.map(m => m.characterDelta)\n        };\n        if (motions.some(m => 'lineDelta' in m)) {\n            motion.lineDelta = motions.map(m => m.lineDelta || 0);\n        }\n        if ('selectionLength' in motions[0]) {\n            motion.selectionLength = motions[0].selectionLength;\n        }\n        return motion;\n    };\n\n    // Detect motion where every cursor has one or more corresponding destinations\n    // with the same relative motion\n    const detectImplicitMotionWithoutGroup = function(document, target, base) {\n        if (target.length === base.length) {\n            return detectUniformMotion(document, target, base);\n        }\n        if (target.length % base.length === 0) {\n            const n = target.length / base.length;\n            return detectSplittingMotion(document, target, base, n);\n        }\n    };\n\n    // Detect motion where every group of cursors moves in the same manner\n    // The first one in each group is used for the base of each motion\n    const detectImplicitMotion = function(document, actual, expected) {\n        for (let groupSize = 1; groupSize <= expected.length; groupSize++) {\n            if (expected.length % groupSize === 0) {\n                const base = expected.filter((_,i) => i % groupSize === 0);\n                const motion = detectImplicitMotionWithoutGroup(document, actual, base);\n                if (motion) {\n                    if (1 < groupSize) {\n                        motion.groupSize = groupSize;\n                    }\n                    return motion;\n                }\n            }\n        }\n    };\n\n    const detectAndRecordImplicitMotion = function(event) {\n        // console.log('cursor', selectionsToString(lastSelections), selectionsToString(event.selections));\n        const document = event.textEditor.document;\n        if (textEditorForPredictions !== event.textEditor || 0 === predictions.length) {\n            const current = Array.from(event.selections);\n            const motion = detectImplicitMotion(document, current, lastSelections);\n            if (motion) {\n                // Here, the occurence of this cursor change event is unexpected.\n                // This type of events includes:\n                //   - cursor movement that happen with snippet insertion related commands\n                //   - cursor movement that happen when the user types in the find input box\n                // We consider it an implicit cursor motion.\n                // We notify it so that it will be recorded to be able to playback.\n                if (aloneEnabled) {\n                    notifyDetectedMotion(CursorMotionType.Alone, motion);\n                }\n                // console.log('motion without prediction');\n            } else {\n                // console.log('skip');\n            }\n        } else {\n            const current = util.sortSelections(event.selections);\n            const match = predictions.findIndex(\n                predicted => util.isEqualSelections(predicted, current)\n            );\n            if (0 <= match) {\n                predictions.splice(0, match + 1);\n                // console.log('match');\n            } else {\n                const predicted = predictions[0];\n                const motion = detectImplicitMotion(document, current, predicted);\n                if (motion) {\n                    // Here, the current cursor position is different from the one predicted.\n                    // This type of events includes:\n                    //   - cursor movement happens right after bracket completion\n                    // We consider it an implicit cursor motion.\n                    // We notify it so that it will be recorded to be able to playback.\n                    notifyDetectedMotion(CursorMotionType.Trailing, motion);\n                    predictions.splice(0, 1);\n                    // console.log('motion with prediction');\n                } else {\n                    // console.log('differ');\n                }\n            }\n        }\n    };\n    const processSelectionChangeEvent = function(event) {\n        if (!enabled) {\n            return;\n        }\n        if (lastTextEditor !== event.textEditor) {\n            lastTextEditor = event.textEditor;\n            lastSelections = event.selections;\n        }\n        detectAndRecordImplicitMotion(event);\n        lastSelections = event.selections;\n    };\n\n    return {\n        CursorMotionType,\n        onDetectCursorMotion,\n        start,\n        stop,\n        setPrediction,\n        getPrediction,\n        setAloneEnabled,\n        processSelectionChangeEvent,\n\n        isEnabled: function() { return enabled; } // testing purpose only\n    }\n};\n\nmodule.exports = { CursorMotionDetector };\n","'use strict';\n\nconst endOfFileDetectorUtil = (function() {\n    const getCursorPosition = function(textEditor) {\n        return textEditor.selections[textEditor.selections.length - 1].active;\n    };\n    const calculateDistanceBelow = function(textEditor) {\n        if (!textEditor) {\n            return [0, 0];\n        }\n        const lineCount = textEditor.document.lineCount;\n        const currentLine = getCursorPosition(textEditor).line;\n        const lineLength = textEditor.document.lineAt(currentLine).text.length;\n        const currentChar = getCursorPosition(textEditor).character;\n        return [\n            Math.max(0, lineCount - 1 - currentLine),\n            Math.max(0, lineLength - currentChar)\n        ];\n    };\n    const compareDistance = function(a, b) {\n        if (a[0] < b[0]) {\n            return -1;\n        } else if (a[0] > b[0]) {\n            return 1;\n        }\n        if (a[1] < b[1]) {\n            return -1;\n        } else if (a[1] > b[1]) {\n            return 1;\n        }\n        return 0;\n    };\n    return {\n        getCursorPosition,\n        calculateDistanceBelow,\n        compareDistance\n    };\n})();\n\nconst EndOfFileDetector = function(textEditor) {\n    let lastDistanceBelow = endOfFileDetectorUtil.calculateDistanceBelow(textEditor);\n\n    // whether distanceBelow[0] is predicted to decline or not\n    let belowLinesDeclines = null;\n\n    const reachedEndOfFile = function() {\n        const distanceBelow = endOfFileDetectorUtil.calculateDistanceBelow(textEditor);\n        const compBelow = endOfFileDetectorUtil.compareDistance(distanceBelow, lastDistanceBelow);\n        if (distanceBelow[0] === 0 && distanceBelow[1] === 0) {\n            // it reached the end of the document\n            return true;\n        }\n        if (compBelow >= 0) {\n            // distance to the bottom of the document should always decline, otherwise we stop\n            return true;\n        }\n        if (belowLinesDeclines === null) {\n            belowLinesDeclines = distanceBelow[0] < lastDistanceBelow[0];\n        } else if (belowLinesDeclines) {\n            if (distanceBelow[0] >= lastDistanceBelow[0]) {\n                // rest lines below the cursor should decline consistently, otherwise, we stop\n                return true;\n            }\n            if (distanceBelow[0] === 0) {\n                // it reached the last line of the document\n                return true;\n            }\n        }\n        lastDistanceBelow = distanceBelow;\n        return false;\n    };\n\n    return {\n        reachedEndOfFile\n    };\n};\n\nmodule.exports = {\n    EndOfFileDetector,\n\n    // testing purpose only\n    endOfFileDetectorUtil\n};\n","'use strict';\nconst vscode = require('vscode');\nconst { AwaitController } = require('./await_controller.js');\nconst { KeyboardMacro } = require('./keyboard_macro.js');\nconst { TypingDetector } = require('./typing_detector.js');\nconst { HelperContext } = require('./helper_context.js');\nconst internalCommands = require('./internal_commands.js');\n\nconst awaitController = AwaitController();\nconst keyboardMacro = KeyboardMacro({ awaitController });\nconst typingDetector = TypingDetector();\nconst helperContext = HelperContext();\n\nfunction activate(context) {\n    const CommandPrefix = 'kb-macro.';\n    const ContextPrefix = 'kb-macro.';\n\n    const registerCommand = function(name, func) {\n        const commandName = CommandPrefix + name;\n        context.subscriptions.push(\n            vscode.commands.registerCommand(commandName, func)\n        );\n    };\n    const addEventListener = function(event, func) {\n        const disposable = event(func);\n        if (disposable) {\n            context.subscriptions.push(disposable);\n        }\n    };\n\n    registerCommand('startRecording', keyboardMacro.startRecording);\n    registerCommand('cancelRecording', keyboardMacro.cancelRecording);\n    registerCommand('finishRecording', keyboardMacro.finishRecording);\n    registerCommand('copyMacroAsKeybinding', keyboardMacro.copyMacroAsKeybinding);\n    registerCommand('playback', keyboardMacro.playback);\n    registerCommand('abortPlayback', keyboardMacro.abortPlayback);\n    registerCommand('repeatPlayback', keyboardMacro.repeatPlayback);\n    registerCommand('repeatPlaybackTillEndOfFile', keyboardMacro.repeatPlaybackTillEndOfFile);\n    registerCommand('wrap', keyboardMacro.wrap);\n\n    keyboardMacro.registerInternalCommand('$type', internalCommands.performType);\n    keyboardMacro.registerInternalCommand('$moveCursor', internalCommands.performCursorMotion);\n\n    const modeIndicator = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 110);\n    modeIndicator.text = \"REC\";\n    context.subscriptions.push(modeIndicator);\n    setInterval(()=>{\n        keyboardMacro.saveSequenceToFile();\n    },60000);\n    addEventListener(\n        keyboardMacro.onChangeRecordingState,\n        function({ recording, reason }) {\n            if (recording) {\n                typingDetector.start();\n            } else {\n                typingDetector.stop();\n            }\n\n            const contextName = ContextPrefix + 'recording';\n            vscode.commands.executeCommand('setContext', contextName, recording);\n\n            if (recording) {\n                modeIndicator.show();\n                vscode.window.setStatusBarMessage('Recording started!', 3000);\n            } else {\n                modeIndicator.hide();\n                if (reason === keyboardMacro.RecordingStateReason.Cancel) {\n                    vscode.window.setStatusBarMessage('Recording canceled!', 3000);\n                } else {\n                    vscode.window.setStatusBarMessage('Recording finished!', 3000);\n                }\n            }\n        }\n    );\n    addEventListener(\n        keyboardMacro.onChangePlaybackState,\n        function({ playing, reason }) {\n            const contextName = ContextPrefix + 'playing';\n            vscode.commands.executeCommand('setContext', contextName, playing);\n\n            if (playing === false && reason === keyboardMacro.PlaybackStateReason.Abort) {\n                vscode.window.setStatusBarMessage('Playback aborted!', 3000);\n            }\n        }\n    );\n    addEventListener(\n        helperContext.onChangeContext,\n        function({ name, value }) {\n            const contextName = ContextPrefix + name;\n            vscode.commands.executeCommand('setContext', contextName, value);\n        }\n    );\n    addEventListener(\n        keyboardMacro.onBeginWrappedCommand,\n        function(wrapMode) {\n            if (wrapMode === 'side-effect') {\n                typingDetector.setAloneEnabled(true);\n            } else {\n                typingDetector.suspend();\n            }\n        }\n    );\n    addEventListener(\n        keyboardMacro.onEndWrappedCommand,\n        function(wrapMode) {\n            if (wrapMode === 'side-effect') {\n                typingDetector.setAloneEnabled(false);\n            } else {\n                typingDetector.resume();\n            }\n        }\n    );\n    addEventListener(\n        vscode.workspace.onDidChangeTextDocument,\n        function(event) {\n            awaitController.processDocumentChangeEvent(event);\n            typingDetector.processDocumentChangeEvent(event);\n        }\n    );\n    addEventListener(\n        vscode.window.onDidChangeTextEditorSelection,\n        function(event) {\n            awaitController.processSelectionChangeEvent(event);\n            typingDetector.processSelectionChangeEvent(event);\n            helperContext.processSelectionChangeEvent(event);\n        }\n    );\n    addEventListener(\n        vscode.window.onDidChangeActiveTextEditor,\n        function(textEditor) {\n            helperContext.processActiveTextEditorChangeEvent(textEditor);\n        }\n    );\n    addEventListener(\n        typingDetector.onDetectTyping,\n        function(type, args) {\n            if (type === typingDetector.TypingType.Direct) {\n                keyboardMacro.push({\n                    command: '$type',\n                    args: args\n                });\n            } else if (type === typingDetector.TypingType.Default) {\n                keyboardMacro.push({\n                    command: 'default:type',\n                    args: args\n                });\n            }\n        }\n    );\n    addEventListener(\n        typingDetector.onDetectCursorMotion,\n        function(type, args) {\n            if (type === typingDetector.CursorMotionType.Trailing ||\n                type === typingDetector.CursorMotionType.Alone) {\n                keyboardMacro.push({\n                    command: '$moveCursor',\n                    args: args\n                });\n            }\n        }\n    );\n\n    helperContext.reset(vscode.window.activeTextEditor);\n}\n\nfunction deactivate() {}\n\nmodule.exports = {\n    activate,\n    deactivate,\n    awaitController,\n    keyboardMacro\n};\n","'use strict';\n\nconst HelperContext = function() {\n    const ContextName = {\n        HeadOfLine: 'headOfLine'\n    };\n    const contextValues = {\n        headOfLine: null\n    };\n    let onChangeContextCallback = null;\n\n    const onChangeContext = function(callback) {\n        onChangeContextCallback = callback;\n    };\n    const update = function(textEditor) {\n        if (!textEditor) {\n            return;\n        }\n        const selections = textEditor.selections;\n        const headOfLine = (\n            selections[0].active.character === 0 &&\n            selections[0].isEmpty &&\n            selections.length === 1\n        );\n        if (contextValues.headOfLine !== headOfLine) {\n            contextValues.headOfLine = headOfLine;\n            if (onChangeContextCallback) {\n                onChangeContextCallback({ name: ContextName.HeadOfLine, value: headOfLine });\n            }\n        }\n    };\n\n    const reset = function(textEditor) {\n        update(textEditor);\n    };\n    const processActiveTextEditorChangeEvent = function(textEditor) {\n        update(textEditor);\n    };\n    const processSelectionChangeEvent = function(event) {\n        update(event.textEditor);\n    };\n\n    const getContext = function(name) {\n        return contextValues[name];\n    };\n\n    return {\n        ContextName,\n        onChangeContext,\n        reset,\n        processActiveTextEditorChangeEvent,\n        processSelectionChangeEvent,\n        getContext\n    };\n};\n\nmodule.exports = { HelperContext };\n","'use strict';\nconst vscode = require('vscode');\nconst util = require('./util.js');\n\nconst internalCommands = (function() {\n    // Performs typing.\n    // This is needed because the existing built-in 'default:type' command is not\n    // appropriate for the purpose since it triggers some unwanted side-effects\n    // like bracket completion.\n    const performType = async function(args) {\n        const textEditor = vscode.window.activeTextEditor;\n        if (!textEditor) {\n            return;\n        }\n        const indices = util.makeIndexOfSortedSelections(textEditor.selections);\n        const text = (args && args.text) || '';\n        const numDeleteLeft = Math.max(0, (args && args.deleteLeft) || 0);\n        const numDeleteRight = Math.max(0, (args && args.deleteRight) || 0);\n        const newSelections = [];\n        await textEditor.edit(edit => {\n            const changes = [];\n            for (let i = 0; i < indices.length; i++) {\n                const selection = textEditor.selections[indices[i]];\n                const range = (function() {\n                    if (0 < numDeleteLeft || 0 < numDeleteRight) {\n                        return new vscode.Range(\n                            selection.active.line,\n                            Math.max(0, selection.active.character - numDeleteLeft),\n                            selection.active.line,\n                            selection.active.character + numDeleteRight\n                        );\n                    } else {\n                        return new vscode.Range(selection.start, selection.end);\n                    }\n                })();\n                if (!range.isEmpty) {\n                    edit.delete(range);\n                }\n                edit.insert(range.start, text);\n                changes[i] = { range, text };\n            }\n            const selections = util.makeSelectionsAfterTyping(changes);\n            for (let i = 0; i < indices.length; i++) {\n                newSelections[indices[i]] = selections[i];\n            }\n        });\n        if (!util.isEqualSelections(textEditor.selections, newSelections)) {\n            textEditor.selections = newSelections;\n        }\n    };\n\n    const translate = function(document, position, lineDelta, characterDelta) {\n        if (lineDelta < 0) {\n            const line = Math.max(0, position.line + lineDelta);\n            const lineLength = document.lineAt(line).text.length;\n            const character = Math.max(0, lineLength + Math.min(characterDelta, 0));\n            return new vscode.Position(line, character);\n        } else if (0 < lineDelta) {\n            const line = Math.min(position.line + lineDelta, document.lineCount - 1);\n            const lineLength = document.lineAt(line).text.length;\n            const character = Math.min(Math.max(0, characterDelta), lineLength);\n            return new vscode.Position(line, character);\n        } else if (lineDelta === 0) {\n            if (characterDelta < 0) {\n                const character = Math.max(0, position.character + characterDelta);\n                return new vscode.Position(position.line, character);\n            } else {\n                const lineLength = document.lineAt(position.line).text.length;\n                const character = Math.min(position.character + characterDelta, lineLength);\n                return new vscode.Position(position.line, character);\n            }\n        }\n    };\n\n    const performCursorMotion = async function(args) {\n        const textEditor = vscode.window.activeTextEditor;\n        if (!textEditor) {\n            return;\n        }\n\n        const document = textEditor.document;\n        const characterDelta = args.characterDelta || 0;\n        let lineDelta = args.lineDelta || 0;\n        const selectionLength = args.selectionLength || 0;\n        const groupSize = args.groupSize || 1;\n\n        let selections = textEditor.selections;\n        if (1 < groupSize) {\n            if (selections.length % groupSize !== 0) {\n                return;\n            }\n            selections = selections.filter((_, i) => i % groupSize === 0);\n        }\n\n        if (Array.isArray(characterDelta)) {\n            // Splitting motion\n            // Each cursor splits into n cursors and goes to locations specified by the args.\n            const n = characterDelta.length;\n            if (!Array.isArray(lineDelta)) {\n                lineDelta = Array(n).fill(lineDelta);\n            }\n            const newSelections = Array.from(selections).flatMap(sel => {\n                return Array.from(Array(n).keys()).map(i => {\n                    const start = translate(document, sel.start, lineDelta[i], characterDelta[i]);\n                    const end = translate(document, start, 0, selectionLength);\n                    return new vscode.Selection(start, end);\n                });\n            });\n            textEditor.selections = newSelections;\n        } else {\n            // Unifor motion\n            // Each cursor moves with the same delta specified by the args.\n            const newSelections = Array.from(selections).map(sel => {\n                const start = translate(document, sel.start, lineDelta, characterDelta);\n                const end = translate(document, start, 0, selectionLength);\n                return new vscode.Selection(start, end);\n            });\n            textEditor.selections = newSelections;\n        }\n    };\n\n    return {\n        performType,\n        performCursorMotion\n    };\n})();\n\nmodule.exports = internalCommands;\n","'use strict';\nconst vscode = require('vscode');\nconst { CommandSequence } = require('./command_sequence.js');\nconst { EndOfFileDetector } = require('./end_of_file_detector.js');\nconst reentrantGuard = require('./reentrant_guard.js');\nconst util = require('./util.js');\n\nconst KeyboardMacro = function({ awaitController }) {\n    const RecordingStateReason = {\n        Start: 0,\n        Cancel: 1,\n        Finish: 2\n    };\n    const PlaybackStateReason = {\n        Start: 0,\n        Abort: 1,\n        Finish: 2\n    };\n\n    let onChangeRecordingStateCallback = null;\n    let onChangePlaybackStateCallback = null;\n    let onBeginWrappedCommandCallback = null;\n    let onEndWrappedCommandCallback = null;\n    let showInputBox = vscode.window.showInputBox; // replaceable for testing\n    let showMessage = vscode.window.showInformationMessage; // replaceable for testing\n    let recording = false;\n    let playing = false;\n    let shouldAbortPlayback = false;\n    const sequence = CommandSequence();\n    const internalCommands = new Map();\n    let last_flushed_sequence_index = 0;\n\n    let printError = defaultPrintError;\n    function defaultPrintError(error) {\n        console.error(error);\n    };\n    const setPrintError = function(printErrorImpl) {\n        const old = printError;\n        printError = printErrorImpl;\n        return old;\n    };\n\n    const onChangeRecordingState = function(callback) {\n        onChangeRecordingStateCallback = callback;\n    };\n    const changeRecordingState = function(newState, reason) {\n        recording = newState;\n        if (onChangeRecordingStateCallback) {\n            onChangeRecordingStateCallback({ recording, reason });\n        }\n    };\n    const onChangePlaybackState = function(callback) {\n        onChangePlaybackStateCallback = callback;\n    };\n    const changePlaybackState = function(newState, reason) {\n        playing = newState;\n        if (onChangePlaybackStateCallback) {\n            onChangePlaybackStateCallback({ playing, reason });\n        }\n    };\n    const onBeginWrappedCommand = function(callback) {\n        onBeginWrappedCommandCallback = callback;\n    };\n    const onEndWrappedCommand = function(callback) {\n        onEndWrappedCommandCallback = callback;\n    };\n\n    const setShowInputBox = function(showInputBoxImpl) {\n        const old = showInputBox;\n        showInputBox = showInputBoxImpl;\n        return old;\n    };\n    const setShowMessage = function(showMessageImpl) {\n        const old = showMessage;\n        showMessage = showMessageImpl;\n        return old;\n    };\n\n    const registerInternalCommand = function(name, func) {\n        internalCommands[name] = func;\n    };\n\n    const startRecording = reentrantGuard.makeGuardedCommandSync(function() {\n        if (!recording) {\n            sequence.clear();\n            last_flushed_sequence_index=0;\n            changeRecordingState(true, RecordingStateReason.Start);\n        }\n    });\n    const cancelRecording = reentrantGuard.makeGuardedCommandSync(function() {\n        if (recording) {\n            sequence.clear();\n            changeRecordingState(false, RecordingStateReason.Cancel);\n        }\n    });\n    const finishRecording = reentrantGuard.makeGuardedCommandSync(function() {\n        if (recording) {\n            //sequence.optimize();\n            var fs = require('fs');\n            let new_flushed_sequence_index=sequence.get().length;\n            for (let i = last_flushed_sequence_index; i < new_flushed_sequence_index; i++) {\n                fs.appendFileSync(\"/workspaces/CodeSpaceTest/extension-test/keystrokes.txt\",JSON.stringify(sequence.get()[i]));\n                fs.appendFileSync(\"/workspaces/CodeSpaceTest/extension-test/keystrokes.txt\",'\\n');\n            }\n            last_flushed_sequence_index=new_flushed_sequence_index;\n            changeRecordingState(false, RecordingStateReason.Finish);\n        }\n    });\n\n    const push = function(spec) {\n        if (recording) {\n            if (spec.record === 'side-effect') {\n                // side-effect mode\n                return;\n            }\n            sequence.push(spec);\n        }\n    };\n    \n    const saveSequenceToFile = function() {\n        if (recording) {\n            //sequence.optimize();\n            var fs = require('fs');\n            let new_flushed_sequence_index=sequence.get().length;\n            for (let i = last_flushed_sequence_index; i < new_flushed_sequence_index; i++) {\n                fs.appendFileSync(\"/workspaces/CodeSpaceTest/extension-test/keystrokes.txt\",JSON.stringify(sequence.get()[i]));\n                fs.appendFileSync(\"/workspaces/CodeSpaceTest/extension-test/keystrokes.txt\",'\\n');\n            }\n            last_flushed_sequence_index=new_flushed_sequence_index;\n        }\n    };\n\n    const copyMacroAsKeybinding = reentrantGuard.makeGuardedCommand(async function() {\n        const commands = sequence.get();\n        if (commands.length === 0) {\n            showMessage('There\\'s no recorded macro.');\n            return;\n        }\n        const macro =\n        '{\\n' +\n        '    \"key\": \"\",\\n' +\n        '    \"command\": \"kb-macro.playback\",\\n' +\n        '    \"args\": {\\n' +\n        '        \"sequence\": [\\n' +\n        commands.map(\n            spec => `            ${JSON.stringify(spec, null, 1).replace(/\\n\\s*/g, ' ')}`\n        ).join(',\\n') + (commands.length === 0 ? '' : '\\n') +\n        '        ]\\n' +\n        '    }\\n' +\n        '}';\n        await vscode.env.clipboard.writeText(macro);\n        showMessage(\n            'Copied the recorded macro to the clipboard!',\n            'Open Keyboard Shortcuts (JSON)'\n        ).then(response => {\n            if (response === 'Open Keyboard Shortcuts (JSON)') {\n                vscode.commands.executeCommand('workbench.action.openGlobalKeybindingsFile');\n            }\n        }, () => {});\n    });\n\n    const invokeCommand = async function(spec) {\n        const func = internalCommands[spec.command];\n        if (func !== undefined) {\n            await func(spec.args);\n        } else {\n            await vscode.commands.executeCommand(\n                spec.command,\n                spec.args\n            );\n        }\n    };\n\n    const invokeCommandSync = async function(spec, context) {\n        let ok = true;\n        const promise = awaitController.waitFor(spec['await'] || '').catch(() => {});\n        try {\n            await invokeCommand(spec);\n        } catch(error) {\n            ok = false;\n            printError(`'kb-macro: ${error.message} - Error in ${context}: ${JSON.stringify(spec)}`);\n        } finally {\n            await promise;\n        }\n        return ok;\n    };\n\n    const validatePlaybackArgs = function(args) {\n        args = (args && typeof(args) === 'object') ? args : {};\n        const validArgs = {};\n        if ('repeat' in args && typeof(args.repeat) === 'number') {\n            validArgs.repeat = args.repeat;\n        }\n        if ('sequence' in args) {\n            if (!Array.isArray(args.sequence)) {\n                showMessage('Invalid \\'sequence\\' argument: ' + JSON.stringify(args.sequence));\n                validArgs.sequence = [];\n            } else {\n                const sequence = args.sequence.map(spec => util.makeCommandSpec(spec));\n                if (sequence.includes(null)) {\n                    showMessage('Invalid \\'sequence\\' argument: ' + JSON.stringify(args.sequence));\n                    validArgs.sequence = [];\n                } else {\n                    validArgs.sequence = sequence;\n                }\n            }\n        }\n        return validArgs;\n    };\n\n    const playbackImpl = async function(args, { tillEndOfFile = false } = {}) {\n        args = validatePlaybackArgs(args);\n        const repeat = 'repeat' in args ? args.repeat : 1;\n        const commands = 'sequence' in args ? args.sequence : sequence.get();\n        const wrapMode = recording ? 'command' : null;\n        if (recording) {\n            if (!('sequence' in args)) {\n                return;\n            }\n        }\n        try {\n            if (wrapMode && onBeginWrappedCommandCallback) {\n                onBeginWrappedCommandCallback(wrapMode);\n            }\n            changePlaybackState(true, PlaybackStateReason.Start);\n            shouldAbortPlayback = false;\n            let endOfFileDetector;\n            if (tillEndOfFile) {\n                endOfFileDetector = EndOfFileDetector(vscode.window.activeTextEditor);\n            }\n            let ok = true;\n            for (let k = 0; k < repeat || tillEndOfFile; k++) {\n                for (const spec of commands) {\n                    ok = await invokeCommandSync(spec, 'playback');\n                    if (!ok || shouldAbortPlayback) {\n                        break;\n                    }\n                    if (wrapMode) {\n                        push(spec);\n                    }\n                }\n                if (!ok || shouldAbortPlayback) {\n                    break;\n                }\n                if (tillEndOfFile) {\n                    if (endOfFileDetector.reachedEndOfFile()) {\n                        break;\n                    }\n                }\n            }\n        } finally {\n            const reason = shouldAbortPlayback ?\n                PlaybackStateReason.Abort :\n                PlaybackStateReason.Finish;\n            changePlaybackState(false, reason);\n            shouldAbortPlayback = false;\n            if (wrapMode && onEndWrappedCommandCallback) {\n                onEndWrappedCommandCallback(wrapMode);\n            }\n        }\n    };\n    const playback = reentrantGuard.makeGuardedCommand(args => playbackImpl(args));\n\n    const abortPlayback = async function() {\n        if (playing) {\n            shouldAbortPlayback = true;\n        }\n    };\n\n    const repeatPlayback = reentrantGuard.makeGuardedCommand(async function() {\n        if (recording) {\n            return;\n        }\n        const input = await showInputBox({\n            prompt: 'Input the number of times to repeat the macro',\n            validateInput: util.validatePositiveIntegerInput\n        });\n        if (input) {\n            const args = {\n                repeat: Number(input)\n            };\n            await playbackImpl(args);\n        }\n    });\n\n    const repeatPlaybackTillEndOfFile = reentrantGuard.makeGuardedCommand(async function() {\n        const args = {};\n        const option = { tillEndOfFile: true };\n        await playbackImpl(args, option);\n    });\n\n    // WrapQueueSize\n    // independently adjustable value.\n    // min value is 1.\n    // greater value reduces input rejection. 2 or 3 is enough.\n    // greater value leads to too many queued and delayed command execution.\n    // See: https://github.com/tshino/vscode-kb-macro/pull/32\n    const WrapQueueSize = 2;\n    const wrapSync = reentrantGuard.makeQueueableCommand(async function(args) {\n        if (recording) {\n            const spec = util.makeCommandSpec(args);\n            if (!spec) {\n                return;\n            }\n            if (spec.command === 'kb-macro.wrap') {\n                return;\n            }\n            if (spec.command === 'kb-macro.playback') {\n                await playbackImpl(spec.args);\n                return;\n            }\n            const wrapMode = spec.record || 'command';\n            if (onBeginWrappedCommandCallback) {\n                onBeginWrappedCommandCallback(wrapMode);\n            }\n            try {\n                const ok = await invokeCommandSync(spec, 'wrap');\n                if (ok) {\n                    push(spec);\n                }\n            } finally {\n                if (onEndWrappedCommandCallback) {\n                    onEndWrappedCommandCallback(wrapMode);\n                }\n            }\n        }\n    }, { queueSize: WrapQueueSize });\n\n    const wrap = function(args) {\n        // Discard the returned Promise.\n        // See https://github.com/tshino/vscode-kb-macro/issues/63\n        wrapSync(args);\n    };\n\n    return {\n        RecordingStateReason,\n        PlaybackStateReason,\n        setPrintError,\n        onChangeRecordingState,\n        onChangePlaybackState,\n        onBeginWrappedCommand,\n        onEndWrappedCommand,\n        registerInternalCommand,\n        startRecording,\n        cancelRecording,\n        finishRecording,\n        push,\n        copyMacroAsKeybinding,\n        validatePlaybackArgs,\n        playback,\n        abortPlayback,\n        repeatPlayback,\n        repeatPlaybackTillEndOfFile,\n        wrapSync,\n        wrap,\n\n        // testing purpose only\n        isRecording: () => { return recording; },\n        isPlaying: () => { return playing; },\n        getCurrentSequence: () => { return sequence.get(); },\n        setShowInputBox,\n        setShowMessage,\n        WrapQueueSize,\n        saveSequenceToFile\n    };\n};\n\nmodule.exports = { KeyboardMacro };","'use strict';\n\nconst reentrantGuard = (function() {\n\n    const state = {\n        locked: false,\n        queueable: false\n    };\n    const queue = [];\n\n    let printError = defaultPrintError;\n    function defaultPrintError(error) {\n        console.error(error);\n        console.info('kb-macro: Exception in guarded command');\n    };\n    const setPrintError = function(printErrorImpl) {\n        const old = printError;\n        printError = printErrorImpl;\n        return old;\n    };\n\n    const makeGuardedCommand = function(body) {\n        return async function(args) {\n            if (state.locked) {\n                return;\n            }\n            state.locked = true;\n            try {\n                await body(args);\n            } catch (error) {\n                printError(error);\n            } finally {\n                state.locked = false;\n            }\n        };\n    };\n    const makeGuardedCommandSync = function(func) {\n        return function(args) {\n            if (state.locked) {\n                return;\n            }\n            state.locked = true;\n            try {\n                func(args);\n            } catch (error) {\n                printError(error);\n            } finally {\n                state.locked = false;\n            }\n        };\n    };\n    const makeQueueableCommand = function(body, { queueSize = 0 } = {}) {\n        return async function(args) {\n            if (state.locked) {\n                if (!state.queueable) {\n                    return;\n                }\n                if (queueSize && queue.length >= queueSize) {\n                    return;\n                }\n                await new Promise(resolve => {\n                    queue.push(resolve);\n                });\n            } else {\n                state.locked = true;\n                state.queueable = true;\n            }\n            try {\n                await body(args);\n            } catch (error) {\n                printError(error);\n            } finally {\n                if (0 < queue.length) {\n                    const resolve = queue[0];\n                    queue.splice(0, 1);\n                    resolve();\n                } else {\n                    state.locked = false;\n                    state.queueable = false;\n                }\n            }\n        };\n    };\n\n    return {\n        makeGuardedCommand,\n        makeGuardedCommandSync,\n        makeQueueableCommand,\n\n        // testing purpose only\n        setPrintError,\n        getQueueLength: function() { return queue.length; }\n    };\n})();\n\nmodule.exports = reentrantGuard;\n","'use strict';\nconst vscode = require('vscode');\nconst util = require('./util.js');\nconst { CursorMotionDetector } = require('./cursor_motion_detector.js');\n\nconst TypingDetector = function() {\n    const TypingType = {\n        Direct: 0,\n        Default: 1\n    };\n    let onDetectTypingCallback  = null;\n    let recording = false;\n    let suspending = false;\n    const cursorMotionDetector = CursorMotionDetector();\n\n    const onDetectTyping = function(callback) {\n        onDetectTypingCallback = callback;\n    };\n    const notifyDetectedTyping = function(type, args) {\n        if (onDetectTypingCallback) {\n            onDetectTypingCallback(type, args);\n        }\n    };\n\n    const start = function() {\n        recording = true;\n        suspending = false;\n        cursorMotionDetector.start(vscode.window.activeTextEditor);\n    };\n    const stop = function() {\n        recording = false;\n        suspending = false;\n        cursorMotionDetector.stop();\n    };\n    const suspend = function() {\n        suspending = true;\n        cursorMotionDetector.stop();\n    };\n    const resume = function() {\n        suspending = false;\n        cursorMotionDetector.start(vscode.window.activeTextEditor);\n    };\n\n    const makePredictionOnBracketCompletion = function(changes) {\n        const sels = [];\n        const offset = changes[0].text.length;\n        for (let i = 0; i + 1 < changes.length; i += 2) {\n            const start = changes[i].range.start.translate(0, offset);\n            const end = changes[i + 1].range.start.translate(0, offset);\n            sels.push(new vscode.Selection(start, end));\n        }\n        return sels;\n    };\n\n    const sortContentChanges = function(changes) {\n        changes = Array.from(changes);\n        changes.sort((a, b) => a.rangeOffset - b.rangeOffset);\n        return changes;\n    };\n    const isUniformTextInsert = function(changes) {\n        const text0 = changes[0].text;\n        const isUniformText = changes.every((chg) => chg.text === text0);\n        return isUniformText && text0 !== '';\n    };\n    const replacesCorrespondingSelection = function(changes, selections) {\n        // every change replaces the text of the respective selection\n        return changes.every((chg, i) => selections[i].isEqual(chg.range));\n    };\n    const isInsertingWithDeleting = function(changes, selections) {\n        const emptySelection = selections.every(sel => sel.isEmpty);\n        if (!emptySelection) {\n            return false;\n        }\n        const uniformRangeLength = changes.every(chg => chg.rangeLength === changes[0].rangeLength);\n        if (!uniformRangeLength) {\n            return false;\n        }\n        const sameLine = selections.every((sel, i) => sel.active.line === changes[i].range.start.line);\n        if (!sameLine) {\n            return false;\n        }\n        const deleteLeft = selections[0].active.character - changes[0].range.start.character;\n        const deleteRight = changes[0].range.end.character - selections[0].active.character;\n        if (deleteLeft < 0 || deleteRight < 0) {\n            return false;\n        }\n        const uniformDeletingLength = selections.every((sel, i) => (\n            deleteLeft === sel.active.character - changes[i].range.start.character &&\n            deleteRight === changes[i].range.end.character - sel.active.character\n        ));\n        return uniformDeletingLength;\n    };\n    const isBracketCompletionWithSelection = function(selections, changes) {\n        let uniformPairedText = changes.every(\n            (chg,i) => chg.text === changes[i % 2].text\n        );\n        return (\n            uniformPairedText &&\n            selections.length * 2 === changes.length &&\n            changes.every(chg => chg.range.isEmpty) &&\n            selections.every((sel,i) => (\n                sel.start.isEqual(changes[i * 2].range.start) &&\n                sel.end.isEqual(changes[i * 2 + 1].range.start)\n            )) &&\n            changes.every(chg => chg.text.length === 1)\n        );\n    };\n\n    const detectTyping = function(textEditor, selections, changes) {\n        if (changes.length === selections.length && isUniformTextInsert(changes)) {\n            if (replacesCorrespondingSelection(changes, selections)) {\n                // Every change is a pure insertion of or replacing the corresponding\n                // selected range with a common text.\n                const prediction = util.makeSelectionsAfterTyping(changes);\n                if (!util.isEqualSelections(selections, prediction)) {\n                    cursorMotionDetector.setPrediction(textEditor, prediction);\n                }\n                notifyDetectedTyping(TypingType.Direct, { text: changes[0].text });\n                return true;\n            }\n            if (isInsertingWithDeleting(changes, selections)) {\n                // Every change (in possible multi-cursor) is a combination of deleting\n                // common number of characters to the left and inserting a common text.\n                // This happens when a code completion occurs.\n                // Example)\n                //  1. type 'a'\n                //  2. type 'r', 'Array' is suggested\n                //  3. accept the suggestion\n                //  4. then edit event happens, that replaces 'ar' with 'Array'\n                const deleteLeft = selections[0].active.character - changes[0].range.start.character;\n                const deleteRight = changes[0].range.end.character - selections[0].active.character;\n                const prediction = util.makeSelectionsAfterTyping(changes);\n                if (!util.isEqualSelections(selections, prediction)) {\n                    cursorMotionDetector.setPrediction(textEditor, prediction);\n                }\n                const args = { text: changes[0].text };\n                if (0 < deleteLeft) {\n                    args.deleteLeft = deleteLeft;\n                }\n                if (0 < deleteRight) {\n                    args.deleteRight = deleteRight;\n                }\n                notifyDetectedTyping(TypingType.Direct, args);\n                return true;\n            }\n        }\n        if (isBracketCompletionWithSelection(selections, changes)) {\n            // It seems like a kind of bracket completion (but not 100% sure).\n            // Supposed senario:\n            //  1. select a text 'hello'\n            //  2. type '('\n            //  3. then a pair of bracket is inserted around 'hello',\n            //     resulting '(hello)'.\n            const prediction = makePredictionOnBracketCompletion(changes);\n            cursorMotionDetector.setPrediction(textEditor, prediction);\n            notifyDetectedTyping(TypingType.Default, { text: changes[0].text });\n            return true;\n        }\n    };\n\n    const processDocumentChangeEvent = function(event) {\n        if (!recording || suspending) {\n            return;\n        }\n        const textEditor = vscode.window.activeTextEditor;\n        if (!textEditor || event.document !== textEditor.document) {\n            return;\n        }\n        if (event.contentChanges.length === 0) {\n            return;\n        }\n\n        const changes = sortContentChanges(event.contentChanges);\n        const prediction = cursorMotionDetector.getPrediction(textEditor);\n        if (prediction) {\n            if (detectTyping(textEditor, prediction, changes)) {\n                return;\n            }\n        }\n        const selections = util.sortSelections(textEditor.selections);\n        detectTyping(textEditor, selections, changes);\n    };\n\n    return {\n        TypingType,\n        CursorMotionType: cursorMotionDetector.CursorMotionType,\n        onDetectTyping,\n        onDetectCursorMotion: cursorMotionDetector.onDetectCursorMotion,\n        start,\n        stop,\n        suspend,\n        resume,\n        setAloneEnabled: cursorMotionDetector.setAloneEnabled,\n        processDocumentChangeEvent,\n        processSelectionChangeEvent : cursorMotionDetector.processSelectionChangeEvent,\n        setPrediction: cursorMotionDetector.setPrediction, // testing purpose only\n        getPrediction: cursorMotionDetector.getPrediction // testing purpose only\n    };\n};\n\nmodule.exports = { TypingDetector };\n","'use strict';\nconst vscode = require('vscode');\n\nconst util = (function() {\n\n    const isEqualSelections = function(selections1, selections2) {\n        return (\n            selections1.length === selections2.length &&\n            selections1.every(\n                (sel1, i) => (\n                    sel1.anchor.isEqual(selections2[i].anchor) &&\n                    sel1.active.isEqual(selections2[i].active)\n                )\n            )\n        );\n    };\n    const sortSelections = function(selections) {\n        selections = Array.from(selections);\n        selections.sort((a, b) => a.start.compareTo(b.start));\n        return selections;\n    };\n    const makeIndexOfSortedSelections = function(selections) {\n        const indices = Array.from({ length: selections.length }, (k,v) => v);\n        indices.sort((a, b) => selections[a].start.compareTo(selections[b].start));\n        return indices;\n    };\n\n    const makeSelectionsAfterTyping = function(sortedChanges) {\n        let lineOffset = 0, lastLine = 0, characterOffset = 0;\n        const newSelections = sortedChanges.map(({ range, text }) => {\n            const numLF = Array.from(text).filter(ch => ch === '\\n').length;\n            if (lastLine !== range.start.line) {\n                characterOffset = 0;\n            }\n            lineOffset += numLF;\n            if (numLF === 0) {\n                characterOffset += text.length;\n            } else {\n                const lenLastLine = text.length - (text.lastIndexOf('\\n') + 1);\n                characterOffset = lenLastLine - range.start.character;\n            }\n            const newPos = new vscode.Position(\n                range.start.line + lineOffset,\n                range.start.character + characterOffset\n            );\n            lineOffset -= range.end.line - range.start.line;\n            lastLine = range.end.line;\n            characterOffset -= range.end.character - range.start.character;\n            return new vscode.Selection(newPos, newPos);\n        });\n        return newSelections;\n    };\n\n    const validatePositiveIntegerInput = function(value) {\n        if (value !== '' && !/^[1-9]\\d*$/.test(value)) {\n            return 'Input a positive integer number';\n        }\n    };\n\n    const makeCommandSpec = function(args) {\n        if (!args || !args.command || typeof(args.command) !== 'string') {\n            return null;\n        }\n        const spec = {\n            command: args.command\n        };\n        if ('args' in args) {\n            spec.args = args.args;\n        }\n        if ('await' in args) {\n            if (typeof(args['await']) !== 'string') {\n                return null;\n            }\n            spec['await'] = args['await'];\n        }\n        if ('record' in args) {\n            if (typeof(args.record) !== 'string') {\n                return null;\n            }\n            spec.record = args.record;\n        }\n        return spec;\n    };\n\n    return {\n        isEqualSelections,\n        sortSelections,\n        makeIndexOfSortedSelections,\n        makeSelectionsAfterTyping,\n        validatePositiveIntegerInput,\n        makeCommandSpec\n    };\n})();\n\nmodule.exports = util;\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(474);\n"],"names":["vscode","module","exports","AwaitController","documentChanged","selectionChanged","sleep","msec","Promise","resolve","setTimeout","waitForClipboardChange","async","timeout","last","env","clipboard","readText","quit","processDocumentChangeEvent","notifiers","Array","from","length","i","processSelectionChangeEvent","waitFor","awaitOption","awaitList","split","promises","resolveFunc","expectedEventCount","doneOne","e","push","console","error","reject","all","CommandSequence","sequence","clear","commandSpec","Date","toISOString","optimize","command","args1","args","args2","characterDelta1","characterDelta","characterDelta2","lineDelta1","lineDelta","lineDelta2","selectionLength2","selectionLength","groupSize1","groupSize","groupSize2","splice","selectionLength1","deleteLeft2","deleteLeft","deleteRight2","deleteRight","text1","text","text2","substr","get","util","CursorMotionDetector","CursorMotionType","Trailing","Alone","onDetectCursorMotionCallback","enabled","aloneEnabled","lastSelections","lastTextEditor","predictions","textEditorForPredictions","notifyDetectedMotion","type","motion","calculateMotion","document","target","base","basePos","start","line","end","character","lineLength","lineAt","equalsMotion","a","b","detectImplicitMotionWithoutGroup","detectUniformMotion","n","motions","j","dest","src","Math","floor","m","map","some","detectSplittingMotion","detectImplicitMotion","actual","expected","filter","_","onDetectCursorMotion","callback","textEditor","selections","stop","setPrediction","getPrediction","setAloneEnabled","event","current","sortSelections","match","findIndex","predicted","isEqualSelections","detectAndRecordImplicitMotion","isEnabled","endOfFileDetectorUtil","getCursorPosition","active","calculateDistanceBelow","lineCount","currentLine","currentChar","max","compareDistance","EndOfFileDetector","lastDistanceBelow","belowLinesDeclines","reachedEndOfFile","distanceBelow","compBelow","KeyboardMacro","TypingDetector","HelperContext","internalCommands","awaitController","keyboardMacro","typingDetector","helperContext","activate","context","registerCommand","name","func","commandName","subscriptions","commands","addEventListener","disposable","startRecording","cancelRecording","finishRecording","copyMacroAsKeybinding","playback","abortPlayback","repeatPlayback","repeatPlaybackTillEndOfFile","wrap","registerInternalCommand","performType","performCursorMotion","modeIndicator","window","createStatusBarItem","StatusBarAlignment","Right","setInterval","saveSequenceToFile","onChangeRecordingState","recording","reason","executeCommand","ContextPrefix","show","setStatusBarMessage","hide","RecordingStateReason","Cancel","onChangePlaybackState","playing","PlaybackStateReason","Abort","onChangeContext","value","contextName","onBeginWrappedCommand","wrapMode","suspend","onEndWrappedCommand","resume","workspace","onDidChangeTextDocument","onDidChangeTextEditorSelection","onDidChangeActiveTextEditor","processActiveTextEditorChangeEvent","onDetectTyping","TypingType","Direct","Default","reset","activeTextEditor","deactivate","ContextName","HeadOfLine","contextValues","headOfLine","onChangeContextCallback","update","isEmpty","getContext","translate","position","min","Position","indices","makeIndexOfSortedSelections","numDeleteLeft","numDeleteRight","newSelections","edit","changes","selection","range","Range","delete","insert","makeSelectionsAfterTyping","isArray","fill","flatMap","sel","keys","Selection","reentrantGuard","Start","Finish","onChangeRecordingStateCallback","onChangePlaybackStateCallback","onBeginWrappedCommandCallback","onEndWrappedCommandCallback","showInputBox","showMessage","showInformationMessage","shouldAbortPlayback","Map","last_flushed_sequence_index","printError","changeRecordingState","newState","changePlaybackState","makeGuardedCommandSync","fs","new_flushed_sequence_index","appendFileSync","JSON","stringify","spec","record","makeGuardedCommand","macro","replace","join","writeText","then","response","invokeCommandSync","ok","promise","catch","undefined","invokeCommand","message","validatePlaybackArgs","validArgs","repeat","makeCommandSpec","includes","playbackImpl","tillEndOfFile","endOfFileDetector","k","input","prompt","validateInput","validatePositiveIntegerInput","Number","wrapSync","makeQueueableCommand","queueSize","setPrintError","printErrorImpl","old","isRecording","isPlaying","getCurrentSequence","setShowInputBox","showInputBoxImpl","setShowMessage","showMessageImpl","WrapQueueSize","state","locked","queueable","queue","info","body","getQueueLength","onDetectTypingCallback","suspending","cursorMotionDetector","notifyDetectedTyping","detectTyping","text0","every","chg","isUniformTextInsert","isEqual","replacesCorrespondingSelection","prediction","rangeLength","sameLine","uniformDeletingLength","isInsertingWithDeleting","uniformPairedText","isBracketCompletionWithSelection","sels","offset","makePredictionOnBracketCompletion","contentChanges","sort","rangeOffset","sortContentChanges","selections1","selections2","sel1","anchor","compareTo","v","sortedChanges","lineOffset","lastLine","characterOffset","numLF","ch","lenLastLine","lastIndexOf","newPos","test","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}