{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://keystroke-recording/./src/await_controller.js","webpack://keystroke-recording/./src/command_sequence.js","webpack://keystroke-recording/./src/cursor_motion_detector.js","webpack://keystroke-recording/./src/end_of_file_detector.js","webpack://keystroke-recording/./src/extension.js","webpack://keystroke-recording/./src/helper_context.js","webpack://keystroke-recording/./src/internal_commands.js","webpack://keystroke-recording/./src/keyboard_macro.js","webpack://keystroke-recording/./src/reentrant_guard.js","webpack://keystroke-recording/./src/typing_detector.js","webpack://keystroke-recording/./src/util.js","webpack://keystroke-recording/external commonjs \"vscode\"","webpack://keystroke-recording/webpack/bootstrap","webpack://keystroke-recording/webpack/startup"],"sourcesContent":["'use strict';\nconst vscode = require('vscode');\n\nconst AwaitController = function() {\n    const DefaultTimeout = 300;\n    const documentChanged = [];\n    const selectionChanged = [];\n\n    const processDocumentChangeEvent = function() {\n        const notifiers = Array.from(documentChanged);\n        documentChanged.length = 0;\n        for (let i = 0; i < notifiers.length; i++) {\n            notifiers[i]();\n        }\n    };\n    const processSelectionChangeEvent = function() {\n        const notifiers = Array.from(selectionChanged);\n        selectionChanged.length = 0;\n        for (let i = 0; i < notifiers.length; i++) {\n            notifiers[i]();\n        }\n    };\n    const sleep = msec => new Promise(resolve => setTimeout(resolve, msec));\n    const waitForClipboardChange = async function(timeout) {\n        const last = await vscode.env.clipboard.readText();\n        let quit = false;\n        setTimeout(() => { quit = true; }, timeout);\n        while (!quit) {\n            await sleep(5);\n            const current = await vscode.env.clipboard.readText();\n            if (current !== last) {\n                return;\n            }\n        }\n        throw 'timeout';\n    };\n\n    const waitFor = function(awaitOption, timeout = DefaultTimeout) {\n        const awaitList = awaitOption.split(' ');\n        const promises = [];\n        let resolveFunc = null;\n        let expectedEventCount = 0;\n        const doneOne = function() {\n            expectedEventCount -= 1;\n            if (expectedEventCount == 0) {\n                resolveFunc();\n            }\n        };\n        for (let i = 0; i < awaitList.length; i++) {\n            const e = awaitList[i];\n            if (e === 'document') {\n                expectedEventCount += 1;\n                documentChanged.push(doneOne);\n            } else if (e === 'selection') {\n                expectedEventCount += 1;\n                selectionChanged.push(doneOne);\n            } else if (e === 'clipboard') {\n                promises.push(waitForClipboardChange(timeout));\n            } else if (e !== '') {\n                console.error('Error (kb-macro): Unknown args.await parameter \"' + e + '\"');\n            }\n        }\n        if (expectedEventCount !== 0) {\n            promises.push(new Promise((resolve, reject) => {\n                resolveFunc = resolve;\n                setTimeout(() => {\n                    if (0 < expectedEventCount) {\n                        expectedEventCount = 0;\n                        reject();\n                    }\n                }, timeout);\n            }));\n        }\n        if (promises.length === 0) {\n            return Promise.resolve(null);\n        } else {\n            return Promise.all(promises);\n        }\n    };\n\n    return {\n        processDocumentChangeEvent,\n        processSelectionChangeEvent,\n        waitFor\n    };\n};\n\nmodule.exports = { AwaitController };\n","'use strict';\n\nconst CommandSequence = function() {\n    const sequence = [];\n\n    const clear = function() {\n        sequence.length = 0;\n    };\n    const push = function(commandSpec) {\n        commandSpec['timestamp']=new Date().toISOString();\n        sequence.push(commandSpec);\n    };\n    const optimize = function() {\n        for (let i = 0; i < sequence.length; i++) {\n            // Remove a pair of cursor movement that results nothing\n            if (i + 1 < sequence.length &&\n                sequence[i].command === '$moveCursor' &&\n                sequence[i + 1].command === '$moveCursor') {\n                const args1 = sequence[i].args || {};\n                const args2 = sequence[i + 1].args || {};\n                const characterDelta1 = args1.characterDelta || 0;\n                const characterDelta2 = args2.characterDelta || 0;\n                const lineDelta1 = args1.lineDelta || 0;\n                const lineDelta2 = args2.lineDelta || 0;\n                const selectionLength2 = args2.selectionLength || 0;\n                const groupSize1 = args1.groupSize || 1;\n                const groupSize2 = args2.groupSize || 1;\n                if (lineDelta1 === 0 &&\n                    lineDelta2 === 0 &&\n                    selectionLength2 === 0 &&\n                    groupSize1 === 1 &&\n                    groupSize2 === 1 &&\n                    characterDelta1 + characterDelta2 === 0) {\n                    sequence.splice(i, 2);\n                    i--;\n                    continue;\n                }\n            }\n            // Combine cursor motion to the left and successive typing with deleting to the right\n            if (i + 1 < sequence.length &&\n                sequence[i].command === '$moveCursor' &&\n                sequence[i + 1].command === '$type') {\n                const args1 = sequence[i].args || {};\n                const args2 = sequence[i + 1].args || {};\n                const characterDelta1 = args1.characterDelta || 0;\n                const lineDelta1 = args1.lineDelta || 0;\n                const selectionLength1 = args1.selectionLength || 0;\n                const groupSize1 = args1.groupSize || 1;\n                const deleteLeft2 = args2.deleteLeft || 0;\n                const deleteRight2 = args2.deleteRight || 0;\n                if (lineDelta1 === 0 &&\n                    selectionLength1 === 0 &&\n                    groupSize1 === 1 &&\n                    characterDelta1 < 0 &&\n                    characterDelta1 + deleteRight2 === 0) {\n                    sequence[i + 1].args.deleteLeft = deleteLeft2 + deleteRight2;\n                    delete sequence[i + 1].args.deleteRight;\n                    sequence.splice(i, 1);\n                    i--;\n                    continue;\n                }\n            }\n            // Concatenate consecutive direct typing\n            if (0 < i &&\n                sequence[i - 1].command === '$type' &&\n                sequence[i].command === '$type'\n            ) {\n                const args1 = sequence[i - 1].args || {};\n                const args2 = sequence[i].args || {};\n                const text1 = args1.text || '';\n                const text2 = args2.text || '';\n                const deleteLeft2 = args2.deleteLeft || 0;\n                const deleteRight2 = args2.deleteRight || 0;\n                if (text1.length >= deleteLeft2 &&\n                    deleteRight2 === 0) {\n                    const text = text1.substr(0, text1.length - deleteLeft2) + text2;\n                    sequence[i - 1].args.text = text;\n                    sequence.splice(i, 1);\n                    i--;\n                    continue;\n                }\n            }\n        }\n    };\n\n    return {\n        clear,\n        push,\n        optimize,\n        get: function() { return sequence; }\n    };\n};\n\nmodule.exports = { CommandSequence };\n","'use strict';\nconst util = require('./util.js');\n\nconst CursorMotionDetector = function() {\n    const CursorMotionType = {\n        Trailing: 0,\n        Alone: 1\n    };\n    let onDetectCursorMotionCallback = null;\n    let enabled = false;\n    let aloneEnabled = false;\n    let lastSelections = null;\n    let lastTextEditor = null;\n    const predictions = [];\n    let textEditorForPredictions = null;\n\n    const onDetectCursorMotion = function(callback) {\n        onDetectCursorMotionCallback = callback;\n    };\n    const notifyDetectedMotion = function(type, motion) {\n        if (onDetectCursorMotionCallback) {\n            onDetectCursorMotionCallback(type, motion);\n        }\n    };\n\n    // const selectionsToString = function(selections) {\n    //     return JSON.stringify(Array.from(selections).map(sel => {\n    //         const { anchor, active } = sel;\n    //         const { line: l1, character: c1 } = anchor;\n    //         const { line: l2, character: c2 } = active;\n    //         if (l1 === l2 && c1 === c2) {\n    //             return [ l1, c1 ];\n    //         } else {\n    //             return [ l1, c1, l2, c2 ];\n    //         }\n    //     }));\n    // };\n\n    const start = function(textEditor) {\n        lastSelections = textEditor ? textEditor.selections : null;\n        lastTextEditor = textEditor || null;\n        predictions.length = 0;\n        textEditorForPredictions = lastTextEditor;\n        enabled = true;\n    };\n    const stop = function() {\n        enabled = false;\n    };\n    const setAloneEnabled = function(enabled) {\n        aloneEnabled = enabled;\n    };\n    const setPrediction = function(textEditor, expected) {\n        if (textEditorForPredictions !== textEditor) {\n            predictions.length = 0;\n            textEditorForPredictions = textEditor;\n        }\n        predictions.push(expected);\n        // console.log('pred', selectionsToString(expected));\n    };\n    const getPrediction = function(textEditor) {\n        if (textEditorForPredictions === textEditor) {\n            return predictions.length === 0 ? null : predictions[predictions.length - 1];\n        } else {\n            return null;\n        }\n    };\n    const calculateMotion = function(document, target, base) {\n        const basePos = base.start;\n        if (target.start.line === basePos.line &&\n            target.start.line === target.end.line &&\n            target.start.character !== basePos.character) {\n            const characterDelta = target.start.character - basePos.character;\n            const selectionLength = target.end.character - target.start.character;\n            if (selectionLength === 0) {\n                return { characterDelta };\n            } else {\n                return { characterDelta, selectionLength };\n            }\n        } else if (target.start.line !== basePos.line &&\n            target.start.line === target.end.line) {\n            const lineDelta = target.start.line - basePos.line;\n            if (lineDelta < 0) {\n                const lineLength = document.lineAt(target.start.line).text.length;\n                const characterDelta = target.start.character - lineLength;\n                const selectionLength = target.end.character - target.start.character;\n                if (selectionLength === 0) {\n                    return { lineDelta, characterDelta };\n                } else {\n                    return { lineDelta, characterDelta, selectionLength };\n                }\n            } else {\n                const characterDelta = target.start.character;\n                const selectionLength = target.end.character - target.start.character;\n                if (selectionLength === 0) {\n                    return { lineDelta, characterDelta };\n                } else {\n                    return { lineDelta, characterDelta, selectionLength };\n                }\n            }\n        }\n    };\n    const equalsMotion = function(a, b) {\n        return (\n            a && b &&\n            a.lineDelta === b.lineDelta &&\n            a.characterDelta === b.characterDelta &&\n            a.selectionLength === b.selectionLength\n        );\n    };\n\n    // Detect motion where each cursor moves with the same set of parameters\n    const detectUniformMotion = function(document, target, base) {\n        const motion = calculateMotion(document, target[0], base[0]);\n        if (!motion) {\n            return;\n        }\n        for (let i = 1; i < target.length; i++) {\n            if (!equalsMotion(motion, calculateMotion(document, target[i], base[i]))) {\n                return;\n            }\n        }\n        // found uniform motion\n        return motion;\n    };\n    // Detect motion where each cursor splits into n cursors in the same ways\n    const detectSplittingMotion = function(document, target, base, n) {\n        const motions = [];\n        for (let j = 0; j < n; j++) {\n            motions[j] = calculateMotion(document, target[j], base[0]);\n            if (!motions[j]) {\n                return;\n            }\n            if (motions[j].selectionLength !== motions[0].selectionLength) {\n                return;\n            }\n        }\n        for (let dest = n; dest < target.length; dest++) {\n            const src = Math.floor(dest / n);\n            const m = calculateMotion(document, target[dest], base[src]);\n            if (!equalsMotion(m, motions[dest % n])) {\n                return;\n            }\n        }\n        // found uniform splitting motion\n        const motion = {\n            characterDelta: motions.map(m => m.characterDelta)\n        };\n        if (motions.some(m => 'lineDelta' in m)) {\n            motion.lineDelta = motions.map(m => m.lineDelta || 0);\n        }\n        if ('selectionLength' in motions[0]) {\n            motion.selectionLength = motions[0].selectionLength;\n        }\n        return motion;\n    };\n\n    // Detect motion where every cursor has one or more corresponding destinations\n    // with the same relative motion\n    const detectImplicitMotionWithoutGroup = function(document, target, base) {\n        if (target.length === base.length) {\n            return detectUniformMotion(document, target, base);\n        }\n        if (target.length % base.length === 0) {\n            const n = target.length / base.length;\n            return detectSplittingMotion(document, target, base, n);\n        }\n    };\n\n    // Detect motion where every group of cursors moves in the same manner\n    // The first one in each group is used for the base of each motion\n    const detectImplicitMotion = function(document, actual, expected) {\n        for (let groupSize = 1; groupSize <= expected.length; groupSize++) {\n            if (expected.length % groupSize === 0) {\n                const base = expected.filter((_,i) => i % groupSize === 0);\n                const motion = detectImplicitMotionWithoutGroup(document, actual, base);\n                if (motion) {\n                    if (1 < groupSize) {\n                        motion.groupSize = groupSize;\n                    }\n                    return motion;\n                }\n            }\n        }\n    };\n\n    const detectAndRecordImplicitMotion = function(event) {\n        // console.log('cursor', selectionsToString(lastSelections), selectionsToString(event.selections));\n        const document = event.textEditor.document;\n        if (textEditorForPredictions !== event.textEditor || 0 === predictions.length) {\n            const current = Array.from(event.selections);\n            const motion = detectImplicitMotion(document, current, lastSelections);\n            if (motion) {\n                // Here, the occurence of this cursor change event is unexpected.\n                // This type of events includes:\n                //   - cursor movement that happen with snippet insertion related commands\n                //   - cursor movement that happen when the user types in the find input box\n                // We consider it an implicit cursor motion.\n                // We notify it so that it will be recorded to be able to playback.\n                if (aloneEnabled) {\n                    notifyDetectedMotion(CursorMotionType.Alone, motion);\n                }\n                // console.log('motion without prediction');\n            } else {\n                // console.log('skip');\n            }\n        } else {\n            const current = util.sortSelections(event.selections);\n            const match = predictions.findIndex(\n                predicted => util.isEqualSelections(predicted, current)\n            );\n            if (0 <= match) {\n                predictions.splice(0, match + 1);\n                // console.log('match');\n            } else {\n                const predicted = predictions[0];\n                const motion = detectImplicitMotion(document, current, predicted);\n                if (motion) {\n                    // Here, the current cursor position is different from the one predicted.\n                    // This type of events includes:\n                    //   - cursor movement happens right after bracket completion\n                    // We consider it an implicit cursor motion.\n                    // We notify it so that it will be recorded to be able to playback.\n                    notifyDetectedMotion(CursorMotionType.Trailing, motion);\n                    predictions.splice(0, 1);\n                    // console.log('motion with prediction');\n                } else {\n                    // console.log('differ');\n                }\n            }\n        }\n    };\n    const processSelectionChangeEvent = function(event) {\n        if (!enabled) {\n            return;\n        }\n        if (lastTextEditor !== event.textEditor) {\n            lastTextEditor = event.textEditor;\n            lastSelections = event.selections;\n        }\n        detectAndRecordImplicitMotion(event);\n        lastSelections = event.selections;\n    };\n\n    return {\n        CursorMotionType,\n        onDetectCursorMotion,\n        start,\n        stop,\n        setPrediction,\n        getPrediction,\n        setAloneEnabled,\n        processSelectionChangeEvent,\n\n        isEnabled: function() { return enabled; } // testing purpose only\n    }\n};\n\nmodule.exports = { CursorMotionDetector };\n","'use strict';\n\nconst endOfFileDetectorUtil = (function() {\n    const getCursorPosition = function(textEditor) {\n        return textEditor.selections[textEditor.selections.length - 1].active;\n    };\n    const calculateDistanceBelow = function(textEditor) {\n        if (!textEditor) {\n            return [0, 0];\n        }\n        const lineCount = textEditor.document.lineCount;\n        const currentLine = getCursorPosition(textEditor).line;\n        const lineLength = textEditor.document.lineAt(currentLine).text.length;\n        const currentChar = getCursorPosition(textEditor).character;\n        return [\n            Math.max(0, lineCount - 1 - currentLine),\n            Math.max(0, lineLength - currentChar)\n        ];\n    };\n    const compareDistance = function(a, b) {\n        if (a[0] < b[0]) {\n            return -1;\n        } else if (a[0] > b[0]) {\n            return 1;\n        }\n        if (a[1] < b[1]) {\n            return -1;\n        } else if (a[1] > b[1]) {\n            return 1;\n        }\n        return 0;\n    };\n    return {\n        getCursorPosition,\n        calculateDistanceBelow,\n        compareDistance\n    };\n})();\n\nconst EndOfFileDetector = function(textEditor) {\n    let lastDistanceBelow = endOfFileDetectorUtil.calculateDistanceBelow(textEditor);\n\n    // whether distanceBelow[0] is predicted to decline or not\n    let belowLinesDeclines = null;\n\n    const reachedEndOfFile = function() {\n        const distanceBelow = endOfFileDetectorUtil.calculateDistanceBelow(textEditor);\n        const compBelow = endOfFileDetectorUtil.compareDistance(distanceBelow, lastDistanceBelow);\n        if (distanceBelow[0] === 0 && distanceBelow[1] === 0) {\n            // it reached the end of the document\n            return true;\n        }\n        if (compBelow >= 0) {\n            // distance to the bottom of the document should always decline, otherwise we stop\n            return true;\n        }\n        if (belowLinesDeclines === null) {\n            belowLinesDeclines = distanceBelow[0] < lastDistanceBelow[0];\n        } else if (belowLinesDeclines) {\n            if (distanceBelow[0] >= lastDistanceBelow[0]) {\n                // rest lines below the cursor should decline consistently, otherwise, we stop\n                return true;\n            }\n            if (distanceBelow[0] === 0) {\n                // it reached the last line of the document\n                return true;\n            }\n        }\n        lastDistanceBelow = distanceBelow;\n        return false;\n    };\n\n    return {\n        reachedEndOfFile\n    };\n};\n\nmodule.exports = {\n    EndOfFileDetector,\n\n    // testing purpose only\n    endOfFileDetectorUtil\n};\n","'use strict';\nconst vscode = require('vscode');\nconst { AwaitController } = require('./await_controller.js');\nconst { KeyboardMacro } = require('./keyboard_macro.js');\nconst { TypingDetector } = require('./typing_detector.js');\nconst { HelperContext } = require('./helper_context.js');\nconst internalCommands = require('./internal_commands.js');\n\nconst awaitController = AwaitController();\nconst keyboardMacro = KeyboardMacro({ awaitController });\nconst typingDetector = TypingDetector();\nconst helperContext = HelperContext();\n\nfunction activate(context) {\n    const CommandPrefix = 'kb-macro.';\n    const ContextPrefix = 'kb-macro.';\n\n    const registerCommand = function(name, func) {\n        const commandName = CommandPrefix + name;\n        context.subscriptions.push(\n            vscode.commands.registerCommand(commandName, func)\n        );\n    };\n    const addEventListener = function(event, func) {\n        const disposable = event(func);\n        if (disposable) {\n            context.subscriptions.push(disposable);\n        }\n    };\n\n    registerCommand('startRecording', keyboardMacro.startRecording);\n    registerCommand('cancelRecording', keyboardMacro.cancelRecording);\n    registerCommand('finishRecording', keyboardMacro.finishRecording);\n    registerCommand('copyMacroAsKeybinding', keyboardMacro.copyMacroAsKeybinding);\n    registerCommand('playback', keyboardMacro.playback);\n    registerCommand('abortPlayback', keyboardMacro.abortPlayback);\n    registerCommand('repeatPlayback', keyboardMacro.repeatPlayback);\n    registerCommand('repeatPlaybackTillEndOfFile', keyboardMacro.repeatPlaybackTillEndOfFile);\n    registerCommand('wrap', keyboardMacro.wrap);\n\n    keyboardMacro.registerInternalCommand('$type', internalCommands.performType);\n    keyboardMacro.registerInternalCommand('$moveCursor', internalCommands.performCursorMotion);\n\n    const modeIndicator = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 110);\n    modeIndicator.text = \"REC\";\n    context.subscriptions.push(modeIndicator);\n\n    addEventListener(\n        keyboardMacro.onChangeRecordingState,\n        function({ recording, reason }) {\n            if (recording) {\n                typingDetector.start();\n            } else {\n                typingDetector.stop();\n            }\n\n            const contextName = ContextPrefix + 'recording';\n            vscode.commands.executeCommand('setContext', contextName, recording);\n\n            if (recording) {\n                modeIndicator.show();\n                vscode.window.setStatusBarMessage('Recording started!', 3000);\n            } else {\n                modeIndicator.hide();\n                if (reason === keyboardMacro.RecordingStateReason.Cancel) {\n                    vscode.window.setStatusBarMessage('Recording canceled!', 3000);\n                } else {\n                    vscode.window.setStatusBarMessage('Recording finished!', 3000);\n                }\n            }\n        }\n    );\n    addEventListener(\n        keyboardMacro.onChangePlaybackState,\n        function({ playing, reason }) {\n            const contextName = ContextPrefix + 'playing';\n            vscode.commands.executeCommand('setContext', contextName, playing);\n\n            if (playing === false && reason === keyboardMacro.PlaybackStateReason.Abort) {\n                vscode.window.setStatusBarMessage('Playback aborted!', 3000);\n            }\n        }\n    );\n    addEventListener(\n        helperContext.onChangeContext,\n        function({ name, value }) {\n            const contextName = ContextPrefix + name;\n            vscode.commands.executeCommand('setContext', contextName, value);\n        }\n    );\n    addEventListener(\n        keyboardMacro.onBeginWrappedCommand,\n        function(wrapMode) {\n            if (wrapMode === 'side-effect') {\n                typingDetector.setAloneEnabled(true);\n            } else {\n                typingDetector.suspend();\n            }\n        }\n    );\n    addEventListener(\n        keyboardMacro.onEndWrappedCommand,\n        function(wrapMode) {\n            if (wrapMode === 'side-effect') {\n                typingDetector.setAloneEnabled(false);\n            } else {\n                typingDetector.resume();\n            }\n        }\n    );\n    addEventListener(\n        vscode.workspace.onDidChangeTextDocument,\n        function(event) {\n            awaitController.processDocumentChangeEvent(event);\n            typingDetector.processDocumentChangeEvent(event);\n        }\n    );\n    addEventListener(\n        vscode.window.onDidChangeTextEditorSelection,\n        function(event) {\n            awaitController.processSelectionChangeEvent(event);\n            typingDetector.processSelectionChangeEvent(event);\n            helperContext.processSelectionChangeEvent(event);\n        }\n    );\n    addEventListener(\n        vscode.window.onDidChangeActiveTextEditor,\n        function(textEditor) {\n            helperContext.processActiveTextEditorChangeEvent(textEditor);\n        }\n    );\n    addEventListener(\n        typingDetector.onDetectTyping,\n        function(type, args) {\n            if (type === typingDetector.TypingType.Direct) {\n                keyboardMacro.push({\n                    command: '$type',\n                    args: args\n                });\n            } else if (type === typingDetector.TypingType.Default) {\n                keyboardMacro.push({\n                    command: 'default:type',\n                    args: args\n                });\n            }\n        }\n    );\n    addEventListener(\n        typingDetector.onDetectCursorMotion,\n        function(type, args) {\n            if (type === typingDetector.CursorMotionType.Trailing ||\n                type === typingDetector.CursorMotionType.Alone) {\n                keyboardMacro.push({\n                    command: '$moveCursor',\n                    args: args\n                });\n            }\n        }\n    );\n\n    helperContext.reset(vscode.window.activeTextEditor);\n}\n\nfunction deactivate() {}\n\nmodule.exports = {\n    activate,\n    deactivate,\n    awaitController,\n    keyboardMacro\n};\n","'use strict';\n\nconst HelperContext = function() {\n    const ContextName = {\n        HeadOfLine: 'headOfLine'\n    };\n    const contextValues = {\n        headOfLine: null\n    };\n    let onChangeContextCallback = null;\n\n    const onChangeContext = function(callback) {\n        onChangeContextCallback = callback;\n    };\n    const update = function(textEditor) {\n        if (!textEditor) {\n            return;\n        }\n        const selections = textEditor.selections;\n        const headOfLine = (\n            selections[0].active.character === 0 &&\n            selections[0].isEmpty &&\n            selections.length === 1\n        );\n        if (contextValues.headOfLine !== headOfLine) {\n            contextValues.headOfLine = headOfLine;\n            if (onChangeContextCallback) {\n                onChangeContextCallback({ name: ContextName.HeadOfLine, value: headOfLine });\n            }\n        }\n    };\n\n    const reset = function(textEditor) {\n        update(textEditor);\n    };\n    const processActiveTextEditorChangeEvent = function(textEditor) {\n        update(textEditor);\n    };\n    const processSelectionChangeEvent = function(event) {\n        update(event.textEditor);\n    };\n\n    const getContext = function(name) {\n        return contextValues[name];\n    };\n\n    return {\n        ContextName,\n        onChangeContext,\n        reset,\n        processActiveTextEditorChangeEvent,\n        processSelectionChangeEvent,\n        getContext\n    };\n};\n\nmodule.exports = { HelperContext };\n","'use strict';\nconst vscode = require('vscode');\nconst util = require('./util.js');\n\nconst internalCommands = (function() {\n    // Performs typing.\n    // This is needed because the existing built-in 'default:type' command is not\n    // appropriate for the purpose since it triggers some unwanted side-effects\n    // like bracket completion.\n    const performType = async function(args) {\n        const textEditor = vscode.window.activeTextEditor;\n        if (!textEditor) {\n            return;\n        }\n        const indices = util.makeIndexOfSortedSelections(textEditor.selections);\n        const text = (args && args.text) || '';\n        const numDeleteLeft = Math.max(0, (args && args.deleteLeft) || 0);\n        const numDeleteRight = Math.max(0, (args && args.deleteRight) || 0);\n        const newSelections = [];\n        await textEditor.edit(edit => {\n            const changes = [];\n            for (let i = 0; i < indices.length; i++) {\n                const selection = textEditor.selections[indices[i]];\n                const range = (function() {\n                    if (0 < numDeleteLeft || 0 < numDeleteRight) {\n                        return new vscode.Range(\n                            selection.active.line,\n                            Math.max(0, selection.active.character - numDeleteLeft),\n                            selection.active.line,\n                            selection.active.character + numDeleteRight\n                        );\n                    } else {\n                        return new vscode.Range(selection.start, selection.end);\n                    }\n                })();\n                if (!range.isEmpty) {\n                    edit.delete(range);\n                }\n                edit.insert(range.start, text);\n                changes[i] = { range, text };\n            }\n            const selections = util.makeSelectionsAfterTyping(changes);\n            for (let i = 0; i < indices.length; i++) {\n                newSelections[indices[i]] = selections[i];\n            }\n        });\n        if (!util.isEqualSelections(textEditor.selections, newSelections)) {\n            textEditor.selections = newSelections;\n        }\n    };\n\n    const translate = function(document, position, lineDelta, characterDelta) {\n        if (lineDelta < 0) {\n            const line = Math.max(0, position.line + lineDelta);\n            const lineLength = document.lineAt(line).text.length;\n            const character = Math.max(0, lineLength + Math.min(characterDelta, 0));\n            return new vscode.Position(line, character);\n        } else if (0 < lineDelta) {\n            const line = Math.min(position.line + lineDelta, document.lineCount - 1);\n            const lineLength = document.lineAt(line).text.length;\n            const character = Math.min(Math.max(0, characterDelta), lineLength);\n            return new vscode.Position(line, character);\n        } else if (lineDelta === 0) {\n            if (characterDelta < 0) {\n                const character = Math.max(0, position.character + characterDelta);\n                return new vscode.Position(position.line, character);\n            } else {\n                const lineLength = document.lineAt(position.line).text.length;\n                const character = Math.min(position.character + characterDelta, lineLength);\n                return new vscode.Position(position.line, character);\n            }\n        }\n    };\n\n    const performCursorMotion = async function(args) {\n        const textEditor = vscode.window.activeTextEditor;\n        if (!textEditor) {\n            return;\n        }\n\n        const document = textEditor.document;\n        const characterDelta = args.characterDelta || 0;\n        let lineDelta = args.lineDelta || 0;\n        const selectionLength = args.selectionLength || 0;\n        const groupSize = args.groupSize || 1;\n\n        let selections = textEditor.selections;\n        if (1 < groupSize) {\n            if (selections.length % groupSize !== 0) {\n                return;\n            }\n            selections = selections.filter((_, i) => i % groupSize === 0);\n        }\n\n        if (Array.isArray(characterDelta)) {\n            // Splitting motion\n            // Each cursor splits into n cursors and goes to locations specified by the args.\n            const n = characterDelta.length;\n            if (!Array.isArray(lineDelta)) {\n                lineDelta = Array(n).fill(lineDelta);\n            }\n            const newSelections = Array.from(selections).flatMap(sel => {\n                return Array.from(Array(n).keys()).map(i => {\n                    const start = translate(document, sel.start, lineDelta[i], characterDelta[i]);\n                    const end = translate(document, start, 0, selectionLength);\n                    return new vscode.Selection(start, end);\n                });\n            });\n            textEditor.selections = newSelections;\n        } else {\n            // Unifor motion\n            // Each cursor moves with the same delta specified by the args.\n            const newSelections = Array.from(selections).map(sel => {\n                const start = translate(document, sel.start, lineDelta, characterDelta);\n                const end = translate(document, start, 0, selectionLength);\n                return new vscode.Selection(start, end);\n            });\n            textEditor.selections = newSelections;\n        }\n    };\n\n    return {\n        performType,\n        performCursorMotion\n    };\n})();\n\nmodule.exports = internalCommands;\n","'use strict';\nconst vscode = require('vscode');\nconst { CommandSequence } = require('./command_sequence.js');\nconst { EndOfFileDetector } = require('./end_of_file_detector.js');\nconst reentrantGuard = require('./reentrant_guard.js');\nconst util = require('./util.js');\n\nconst KeyboardMacro = function({ awaitController }) {\n    const RecordingStateReason = {\n        Start: 0,\n        Cancel: 1,\n        Finish: 2\n    };\n    const PlaybackStateReason = {\n        Start: 0,\n        Abort: 1,\n        Finish: 2\n    };\n\n    let onChangeRecordingStateCallback = null;\n    let onChangePlaybackStateCallback = null;\n    let onBeginWrappedCommandCallback = null;\n    let onEndWrappedCommandCallback = null;\n    let showInputBox = vscode.window.showInputBox; // replaceable for testing\n    let showMessage = vscode.window.showInformationMessage; // replaceable for testing\n    let recording = false;\n    let playing = false;\n    let shouldAbortPlayback = false;\n    const sequence = CommandSequence();\n    const internalCommands = new Map();\n\n    let printError = defaultPrintError;\n    function defaultPrintError(error) {\n        console.error(error);\n    };\n    const setPrintError = function(printErrorImpl) {\n        const old = printError;\n        printError = printErrorImpl;\n        return old;\n    };\n\n    const onChangeRecordingState = function(callback) {\n        onChangeRecordingStateCallback = callback;\n    };\n    const changeRecordingState = function(newState, reason) {\n        recording = newState;\n        if (onChangeRecordingStateCallback) {\n            onChangeRecordingStateCallback({ recording, reason });\n        }\n    };\n    const onChangePlaybackState = function(callback) {\n        onChangePlaybackStateCallback = callback;\n    };\n    const changePlaybackState = function(newState, reason) {\n        playing = newState;\n        if (onChangePlaybackStateCallback) {\n            onChangePlaybackStateCallback({ playing, reason });\n        }\n    };\n    const onBeginWrappedCommand = function(callback) {\n        onBeginWrappedCommandCallback = callback;\n    };\n    const onEndWrappedCommand = function(callback) {\n        onEndWrappedCommandCallback = callback;\n    };\n\n    const setShowInputBox = function(showInputBoxImpl) {\n        const old = showInputBox;\n        showInputBox = showInputBoxImpl;\n        return old;\n    };\n    const setShowMessage = function(showMessageImpl) {\n        const old = showMessage;\n        showMessage = showMessageImpl;\n        return old;\n    };\n\n    const registerInternalCommand = function(name, func) {\n        internalCommands[name] = func;\n    };\n\n    const startRecording = reentrantGuard.makeGuardedCommandSync(function() {\n        if (!recording) {\n            sequence.clear();\n            changeRecordingState(true, RecordingStateReason.Start);\n        }\n    });\n    const cancelRecording = reentrantGuard.makeGuardedCommandSync(function() {\n        if (recording) {\n            sequence.clear();\n            changeRecordingState(false, RecordingStateReason.Cancel);\n        }\n    });\n    const finishRecording = reentrantGuard.makeGuardedCommandSync(function() {\n        if (recording) {\n            sequence.optimize();\n            changeRecordingState(false, RecordingStateReason.Finish);\n        }\n    });\n\n    const push = function(spec) {\n        if (recording) {\n            if (spec.record === 'side-effect') {\n                // side-effect mode\n                return;\n            }\n            sequence.push(spec);\n        }\n    };\n\n    const copyMacroAsKeybinding = reentrantGuard.makeGuardedCommand(async function() {\n        const commands = sequence.get();\n        if (commands.length === 0) {\n            showMessage('There\\'s no recorded macro.');\n            return;\n        }\n        const macro =\n        '{\\n' +\n        '    \"key\": \"\",\\n' +\n        '    \"command\": \"kb-macro.playback\",\\n' +\n        '    \"args\": {\\n' +\n        '        \"sequence\": [\\n' +\n        commands.map(\n            spec => `            ${JSON.stringify(spec, null, 1).replace(/\\n\\s*/g, ' ')}`\n        ).join(',\\n') + (commands.length === 0 ? '' : '\\n') +\n        '        ]\\n' +\n        '    }\\n' +\n        '}';\n        await vscode.env.clipboard.writeText(macro);\n        showMessage(\n            'Copied the recorded macro to the clipboard!',\n            'Open Keyboard Shortcuts (JSON)'\n        ).then(response => {\n            if (response === 'Open Keyboard Shortcuts (JSON)') {\n                vscode.commands.executeCommand('workbench.action.openGlobalKeybindingsFile');\n            }\n        }, () => {});\n    });\n\n    const invokeCommand = async function(spec) {\n        const func = internalCommands[spec.command];\n        if (func !== undefined) {\n            await func(spec.args);\n        } else {\n            await vscode.commands.executeCommand(\n                spec.command,\n                spec.args\n            );\n        }\n    };\n\n    const invokeCommandSync = async function(spec, context) {\n        let ok = true;\n        const promise = awaitController.waitFor(spec['await'] || '').catch(() => {});\n        try {\n            await invokeCommand(spec);\n        } catch(error) {\n            ok = false;\n            printError(`'kb-macro: ${error.message} - Error in ${context}: ${JSON.stringify(spec)}`);\n        } finally {\n            await promise;\n        }\n        return ok;\n    };\n\n    const validatePlaybackArgs = function(args) {\n        args = (args && typeof(args) === 'object') ? args : {};\n        const validArgs = {};\n        if ('repeat' in args && typeof(args.repeat) === 'number') {\n            validArgs.repeat = args.repeat;\n        }\n        if ('sequence' in args) {\n            if (!Array.isArray(args.sequence)) {\n                showMessage('Invalid \\'sequence\\' argument: ' + JSON.stringify(args.sequence));\n                validArgs.sequence = [];\n            } else {\n                const sequence = args.sequence.map(spec => util.makeCommandSpec(spec));\n                if (sequence.includes(null)) {\n                    showMessage('Invalid \\'sequence\\' argument: ' + JSON.stringify(args.sequence));\n                    validArgs.sequence = [];\n                } else {\n                    validArgs.sequence = sequence;\n                }\n            }\n        }\n        return validArgs;\n    };\n\n    const playbackImpl = async function(args, { tillEndOfFile = false } = {}) {\n        args = validatePlaybackArgs(args);\n        const repeat = 'repeat' in args ? args.repeat : 1;\n        const commands = 'sequence' in args ? args.sequence : sequence.get();\n        const wrapMode = recording ? 'command' : null;\n        if (recording) {\n            if (!('sequence' in args)) {\n                return;\n            }\n        }\n        try {\n            if (wrapMode && onBeginWrappedCommandCallback) {\n                onBeginWrappedCommandCallback(wrapMode);\n            }\n            changePlaybackState(true, PlaybackStateReason.Start);\n            shouldAbortPlayback = false;\n            let endOfFileDetector;\n            if (tillEndOfFile) {\n                endOfFileDetector = EndOfFileDetector(vscode.window.activeTextEditor);\n            }\n            let ok = true;\n            for (let k = 0; k < repeat || tillEndOfFile; k++) {\n                for (const spec of commands) {\n                    ok = await invokeCommandSync(spec, 'playback');\n                    if (!ok || shouldAbortPlayback) {\n                        break;\n                    }\n                    if (wrapMode) {\n                        push(spec);\n                    }\n                }\n                if (!ok || shouldAbortPlayback) {\n                    break;\n                }\n                if (tillEndOfFile) {\n                    if (endOfFileDetector.reachedEndOfFile()) {\n                        break;\n                    }\n                }\n            }\n        } finally {\n            const reason = shouldAbortPlayback ?\n                PlaybackStateReason.Abort :\n                PlaybackStateReason.Finish;\n            changePlaybackState(false, reason);\n            shouldAbortPlayback = false;\n            if (wrapMode && onEndWrappedCommandCallback) {\n                onEndWrappedCommandCallback(wrapMode);\n            }\n        }\n    };\n    const playback = reentrantGuard.makeGuardedCommand(args => playbackImpl(args));\n\n    const abortPlayback = async function() {\n        if (playing) {\n            shouldAbortPlayback = true;\n        }\n    };\n\n    const repeatPlayback = reentrantGuard.makeGuardedCommand(async function() {\n        if (recording) {\n            return;\n        }\n        const input = await showInputBox({\n            prompt: 'Input the number of times to repeat the macro',\n            validateInput: util.validatePositiveIntegerInput\n        });\n        if (input) {\n            const args = {\n                repeat: Number(input)\n            };\n            await playbackImpl(args);\n        }\n    });\n\n    const repeatPlaybackTillEndOfFile = reentrantGuard.makeGuardedCommand(async function() {\n        const args = {};\n        const option = { tillEndOfFile: true };\n        await playbackImpl(args, option);\n    });\n\n    // WrapQueueSize\n    // independently adjustable value.\n    // min value is 1.\n    // greater value reduces input rejection. 2 or 3 is enough.\n    // greater value leads to too many queued and delayed command execution.\n    // See: https://github.com/tshino/vscode-kb-macro/pull/32\n    const WrapQueueSize = 2;\n    const wrapSync = reentrantGuard.makeQueueableCommand(async function(args) {\n        if (recording) {\n            const spec = util.makeCommandSpec(args);\n            if (!spec) {\n                return;\n            }\n            if (spec.command === 'kb-macro.wrap') {\n                return;\n            }\n            if (spec.command === 'kb-macro.playback') {\n                await playbackImpl(spec.args);\n                return;\n            }\n            const wrapMode = spec.record || 'command';\n            if (onBeginWrappedCommandCallback) {\n                onBeginWrappedCommandCallback(wrapMode);\n            }\n            try {\n                const ok = await invokeCommandSync(spec, 'wrap');\n                if (ok) {\n                    push(spec);\n                }\n            } finally {\n                if (onEndWrappedCommandCallback) {\n                    onEndWrappedCommandCallback(wrapMode);\n                }\n            }\n        }\n    }, { queueSize: WrapQueueSize });\n\n    const wrap = function(args) {\n        // Discard the returned Promise.\n        // See https://github.com/tshino/vscode-kb-macro/issues/63\n        wrapSync(args);\n    };\n\n    return {\n        RecordingStateReason,\n        PlaybackStateReason,\n        setPrintError,\n        onChangeRecordingState,\n        onChangePlaybackState,\n        onBeginWrappedCommand,\n        onEndWrappedCommand,\n        registerInternalCommand,\n        startRecording,\n        cancelRecording,\n        finishRecording,\n        push,\n        copyMacroAsKeybinding,\n        validatePlaybackArgs,\n        playback,\n        abortPlayback,\n        repeatPlayback,\n        repeatPlaybackTillEndOfFile,\n        wrapSync,\n        wrap,\n\n        // testing purpose only\n        isRecording: () => { return recording; },\n        isPlaying: () => { return playing; },\n        getCurrentSequence: () => { return sequence.get(); },\n        setShowInputBox,\n        setShowMessage,\n        WrapQueueSize\n    };\n};\n\nmodule.exports = { KeyboardMacro };\n","'use strict';\n\nconst reentrantGuard = (function() {\n\n    const state = {\n        locked: false,\n        queueable: false\n    };\n    const queue = [];\n\n    let printError = defaultPrintError;\n    function defaultPrintError(error) {\n        console.error(error);\n        console.info('kb-macro: Exception in guarded command');\n    };\n    const setPrintError = function(printErrorImpl) {\n        const old = printError;\n        printError = printErrorImpl;\n        return old;\n    };\n\n    const makeGuardedCommand = function(body) {\n        return async function(args) {\n            if (state.locked) {\n                return;\n            }\n            state.locked = true;\n            try {\n                await body(args);\n            } catch (error) {\n                printError(error);\n            } finally {\n                state.locked = false;\n            }\n        };\n    };\n    const makeGuardedCommandSync = function(func) {\n        return function(args) {\n            if (state.locked) {\n                return;\n            }\n            state.locked = true;\n            try {\n                func(args);\n            } catch (error) {\n                printError(error);\n            } finally {\n                state.locked = false;\n            }\n        };\n    };\n    const makeQueueableCommand = function(body, { queueSize = 0 } = {}) {\n        return async function(args) {\n            if (state.locked) {\n                if (!state.queueable) {\n                    return;\n                }\n                if (queueSize && queue.length >= queueSize) {\n                    return;\n                }\n                await new Promise(resolve => {\n                    queue.push(resolve);\n                });\n            } else {\n                state.locked = true;\n                state.queueable = true;\n            }\n            try {\n                await body(args);\n            } catch (error) {\n                printError(error);\n            } finally {\n                if (0 < queue.length) {\n                    const resolve = queue[0];\n                    queue.splice(0, 1);\n                    resolve();\n                } else {\n                    state.locked = false;\n                    state.queueable = false;\n                }\n            }\n        };\n    };\n\n    return {\n        makeGuardedCommand,\n        makeGuardedCommandSync,\n        makeQueueableCommand,\n\n        // testing purpose only\n        setPrintError,\n        getQueueLength: function() { return queue.length; }\n    };\n})();\n\nmodule.exports = reentrantGuard;\n","'use strict';\nconst vscode = require('vscode');\nconst util = require('./util.js');\nconst { CursorMotionDetector } = require('./cursor_motion_detector.js');\n\nconst TypingDetector = function() {\n    const TypingType = {\n        Direct: 0,\n        Default: 1\n    };\n    let onDetectTypingCallback  = null;\n    let recording = false;\n    let suspending = false;\n    const cursorMotionDetector = CursorMotionDetector();\n\n    const onDetectTyping = function(callback) {\n        onDetectTypingCallback = callback;\n    };\n    const notifyDetectedTyping = function(type, args) {\n        if (onDetectTypingCallback) {\n            onDetectTypingCallback(type, args);\n        }\n    };\n\n    const start = function() {\n        recording = true;\n        suspending = false;\n        cursorMotionDetector.start(vscode.window.activeTextEditor);\n    };\n    const stop = function() {\n        recording = false;\n        suspending = false;\n        cursorMotionDetector.stop();\n    };\n    const suspend = function() {\n        suspending = true;\n        cursorMotionDetector.stop();\n    };\n    const resume = function() {\n        suspending = false;\n        cursorMotionDetector.start(vscode.window.activeTextEditor);\n    };\n\n    const makePredictionOnBracketCompletion = function(changes) {\n        const sels = [];\n        const offset = changes[0].text.length;\n        for (let i = 0; i + 1 < changes.length; i += 2) {\n            const start = changes[i].range.start.translate(0, offset);\n            const end = changes[i + 1].range.start.translate(0, offset);\n            sels.push(new vscode.Selection(start, end));\n        }\n        return sels;\n    };\n\n    const sortContentChanges = function(changes) {\n        changes = Array.from(changes);\n        changes.sort((a, b) => a.rangeOffset - b.rangeOffset);\n        return changes;\n    };\n    const isUniformTextInsert = function(changes) {\n        const text0 = changes[0].text;\n        const isUniformText = changes.every((chg) => chg.text === text0);\n        return isUniformText && text0 !== '';\n    };\n    const replacesCorrespondingSelection = function(changes, selections) {\n        // every change replaces the text of the respective selection\n        return changes.every((chg, i) => selections[i].isEqual(chg.range));\n    };\n    const isInsertingWithDeleting = function(changes, selections) {\n        const emptySelection = selections.every(sel => sel.isEmpty);\n        if (!emptySelection) {\n            return false;\n        }\n        const uniformRangeLength = changes.every(chg => chg.rangeLength === changes[0].rangeLength);\n        if (!uniformRangeLength) {\n            return false;\n        }\n        const sameLine = selections.every((sel, i) => sel.active.line === changes[i].range.start.line);\n        if (!sameLine) {\n            return false;\n        }\n        const deleteLeft = selections[0].active.character - changes[0].range.start.character;\n        const deleteRight = changes[0].range.end.character - selections[0].active.character;\n        if (deleteLeft < 0 || deleteRight < 0) {\n            return false;\n        }\n        const uniformDeletingLength = selections.every((sel, i) => (\n            deleteLeft === sel.active.character - changes[i].range.start.character &&\n            deleteRight === changes[i].range.end.character - sel.active.character\n        ));\n        return uniformDeletingLength;\n    };\n    const isBracketCompletionWithSelection = function(selections, changes) {\n        let uniformPairedText = changes.every(\n            (chg,i) => chg.text === changes[i % 2].text\n        );\n        return (\n            uniformPairedText &&\n            selections.length * 2 === changes.length &&\n            changes.every(chg => chg.range.isEmpty) &&\n            selections.every((sel,i) => (\n                sel.start.isEqual(changes[i * 2].range.start) &&\n                sel.end.isEqual(changes[i * 2 + 1].range.start)\n            )) &&\n            changes.every(chg => chg.text.length === 1)\n        );\n    };\n\n    const detectTyping = function(textEditor, selections, changes) {\n        if (changes.length === selections.length && isUniformTextInsert(changes)) {\n            if (replacesCorrespondingSelection(changes, selections)) {\n                // Every change is a pure insertion of or replacing the corresponding\n                // selected range with a common text.\n                const prediction = util.makeSelectionsAfterTyping(changes);\n                if (!util.isEqualSelections(selections, prediction)) {\n                    cursorMotionDetector.setPrediction(textEditor, prediction);\n                }\n                notifyDetectedTyping(TypingType.Direct, { text: changes[0].text });\n                return true;\n            }\n            if (isInsertingWithDeleting(changes, selections)) {\n                // Every change (in possible multi-cursor) is a combination of deleting\n                // common number of characters to the left and inserting a common text.\n                // This happens when a code completion occurs.\n                // Example)\n                //  1. type 'a'\n                //  2. type 'r', 'Array' is suggested\n                //  3. accept the suggestion\n                //  4. then edit event happens, that replaces 'ar' with 'Array'\n                const deleteLeft = selections[0].active.character - changes[0].range.start.character;\n                const deleteRight = changes[0].range.end.character - selections[0].active.character;\n                const prediction = util.makeSelectionsAfterTyping(changes);\n                if (!util.isEqualSelections(selections, prediction)) {\n                    cursorMotionDetector.setPrediction(textEditor, prediction);\n                }\n                const args = { text: changes[0].text };\n                if (0 < deleteLeft) {\n                    args.deleteLeft = deleteLeft;\n                }\n                if (0 < deleteRight) {\n                    args.deleteRight = deleteRight;\n                }\n                notifyDetectedTyping(TypingType.Direct, args);\n                return true;\n            }\n        }\n        if (isBracketCompletionWithSelection(selections, changes)) {\n            // It seems like a kind of bracket completion (but not 100% sure).\n            // Supposed senario:\n            //  1. select a text 'hello'\n            //  2. type '('\n            //  3. then a pair of bracket is inserted around 'hello',\n            //     resulting '(hello)'.\n            const prediction = makePredictionOnBracketCompletion(changes);\n            cursorMotionDetector.setPrediction(textEditor, prediction);\n            notifyDetectedTyping(TypingType.Default, { text: changes[0].text });\n            return true;\n        }\n    };\n\n    const processDocumentChangeEvent = function(event) {\n        if (!recording || suspending) {\n            return;\n        }\n        const textEditor = vscode.window.activeTextEditor;\n        if (!textEditor || event.document !== textEditor.document) {\n            return;\n        }\n        if (event.contentChanges.length === 0) {\n            return;\n        }\n\n        const changes = sortContentChanges(event.contentChanges);\n        const prediction = cursorMotionDetector.getPrediction(textEditor);\n        if (prediction) {\n            if (detectTyping(textEditor, prediction, changes)) {\n                return;\n            }\n        }\n        const selections = util.sortSelections(textEditor.selections);\n        detectTyping(textEditor, selections, changes);\n    };\n\n    return {\n        TypingType,\n        CursorMotionType: cursorMotionDetector.CursorMotionType,\n        onDetectTyping,\n        onDetectCursorMotion: cursorMotionDetector.onDetectCursorMotion,\n        start,\n        stop,\n        suspend,\n        resume,\n        setAloneEnabled: cursorMotionDetector.setAloneEnabled,\n        processDocumentChangeEvent,\n        processSelectionChangeEvent : cursorMotionDetector.processSelectionChangeEvent,\n        setPrediction: cursorMotionDetector.setPrediction, // testing purpose only\n        getPrediction: cursorMotionDetector.getPrediction // testing purpose only\n    };\n};\n\nmodule.exports = { TypingDetector };\n","'use strict';\nconst vscode = require('vscode');\n\nconst util = (function() {\n\n    const isEqualSelections = function(selections1, selections2) {\n        return (\n            selections1.length === selections2.length &&\n            selections1.every(\n                (sel1, i) => (\n                    sel1.anchor.isEqual(selections2[i].anchor) &&\n                    sel1.active.isEqual(selections2[i].active)\n                )\n            )\n        );\n    };\n    const sortSelections = function(selections) {\n        selections = Array.from(selections);\n        selections.sort((a, b) => a.start.compareTo(b.start));\n        return selections;\n    };\n    const makeIndexOfSortedSelections = function(selections) {\n        const indices = Array.from({ length: selections.length }, (k,v) => v);\n        indices.sort((a, b) => selections[a].start.compareTo(selections[b].start));\n        return indices;\n    };\n\n    const makeSelectionsAfterTyping = function(sortedChanges) {\n        let lineOffset = 0, lastLine = 0, characterOffset = 0;\n        const newSelections = sortedChanges.map(({ range, text }) => {\n            const numLF = Array.from(text).filter(ch => ch === '\\n').length;\n            if (lastLine !== range.start.line) {\n                characterOffset = 0;\n            }\n            lineOffset += numLF;\n            if (numLF === 0) {\n                characterOffset += text.length;\n            } else {\n                const lenLastLine = text.length - (text.lastIndexOf('\\n') + 1);\n                characterOffset = lenLastLine - range.start.character;\n            }\n            const newPos = new vscode.Position(\n                range.start.line + lineOffset,\n                range.start.character + characterOffset\n            );\n            lineOffset -= range.end.line - range.start.line;\n            lastLine = range.end.line;\n            characterOffset -= range.end.character - range.start.character;\n            return new vscode.Selection(newPos, newPos);\n        });\n        return newSelections;\n    };\n\n    const validatePositiveIntegerInput = function(value) {\n        if (value !== '' && !/^[1-9]\\d*$/.test(value)) {\n            return 'Input a positive integer number';\n        }\n    };\n\n    const makeCommandSpec = function(args) {\n        if (!args || !args.command || typeof(args.command) !== 'string') {\n            return null;\n        }\n        const spec = {\n            command: args.command\n        };\n        if ('args' in args) {\n            spec.args = args.args;\n        }\n        if ('await' in args) {\n            if (typeof(args['await']) !== 'string') {\n                return null;\n            }\n            spec['await'] = args['await'];\n        }\n        if ('record' in args) {\n            if (typeof(args.record) !== 'string') {\n                return null;\n            }\n            spec.record = args.record;\n        }\n        return spec;\n    };\n\n    return {\n        isEqualSelections,\n        sortSelections,\n        makeIndexOfSortedSelections,\n        makeSelectionsAfterTyping,\n        validatePositiveIntegerInput,\n        makeCommandSpec\n    };\n})();\n\nmodule.exports = util;\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(474);\n"],"names":["vscode","module","exports","AwaitController","documentChanged","selectionChanged","sleep","msec","Promise","resolve","setTimeout","waitForClipboardChange","async","timeout","last","env","clipboard","readText","quit","processDocumentChangeEvent","notifiers","Array","from","length","i","processSelectionChangeEvent","waitFor","awaitOption","awaitList","split","promises","resolveFunc","expectedEventCount","doneOne","e","push","console","error","reject","all","CommandSequence","sequence","clear","commandSpec","Date","toISOString","optimize","command","args1","args","args2","characterDelta1","characterDelta","characterDelta2","lineDelta1","lineDelta","lineDelta2","selectionLength2","selectionLength","groupSize1","groupSize","groupSize2","splice","selectionLength1","deleteLeft2","deleteLeft","deleteRight2","deleteRight","text1","text","text2","substr","get","util","CursorMotionDetector","CursorMotionType","Trailing","Alone","onDetectCursorMotionCallback","enabled","aloneEnabled","lastSelections","lastTextEditor","predictions","textEditorForPredictions","notifyDetectedMotion","type","motion","calculateMotion","document","target","base","basePos","start","line","end","character","lineLength","lineAt","equalsMotion","a","b","detectImplicitMotionWithoutGroup","detectUniformMotion","n","motions","j","dest","src","Math","floor","m","map","some","detectSplittingMotion","detectImplicitMotion","actual","expected","filter","_","onDetectCursorMotion","callback","textEditor","selections","stop","setPrediction","getPrediction","setAloneEnabled","event","current","sortSelections","match","findIndex","predicted","isEqualSelections","detectAndRecordImplicitMotion","isEnabled","endOfFileDetectorUtil","getCursorPosition","active","calculateDistanceBelow","lineCount","currentLine","currentChar","max","compareDistance","EndOfFileDetector","lastDistanceBelow","belowLinesDeclines","reachedEndOfFile","distanceBelow","compBelow","KeyboardMacro","TypingDetector","HelperContext","internalCommands","awaitController","keyboardMacro","typingDetector","helperContext","activate","context","registerCommand","name","func","commandName","subscriptions","commands","addEventListener","disposable","startRecording","cancelRecording","finishRecording","copyMacroAsKeybinding","playback","abortPlayback","repeatPlayback","repeatPlaybackTillEndOfFile","wrap","registerInternalCommand","performType","performCursorMotion","modeIndicator","window","createStatusBarItem","StatusBarAlignment","Right","onChangeRecordingState","recording","reason","executeCommand","ContextPrefix","show","setStatusBarMessage","hide","RecordingStateReason","Cancel","onChangePlaybackState","playing","PlaybackStateReason","Abort","onChangeContext","value","contextName","onBeginWrappedCommand","wrapMode","suspend","onEndWrappedCommand","resume","workspace","onDidChangeTextDocument","onDidChangeTextEditorSelection","onDidChangeActiveTextEditor","processActiveTextEditorChangeEvent","onDetectTyping","TypingType","Direct","Default","reset","activeTextEditor","deactivate","ContextName","HeadOfLine","contextValues","headOfLine","onChangeContextCallback","update","isEmpty","getContext","translate","position","min","Position","indices","makeIndexOfSortedSelections","numDeleteLeft","numDeleteRight","newSelections","edit","changes","selection","range","Range","delete","insert","makeSelectionsAfterTyping","isArray","fill","flatMap","sel","keys","Selection","reentrantGuard","Start","Finish","onChangeRecordingStateCallback","onChangePlaybackStateCallback","onBeginWrappedCommandCallback","onEndWrappedCommandCallback","showInputBox","showMessage","showInformationMessage","shouldAbortPlayback","Map","printError","changeRecordingState","newState","changePlaybackState","makeGuardedCommandSync","spec","record","makeGuardedCommand","macro","JSON","stringify","replace","join","writeText","then","response","invokeCommandSync","ok","promise","catch","undefined","invokeCommand","message","validatePlaybackArgs","validArgs","repeat","makeCommandSpec","includes","playbackImpl","tillEndOfFile","endOfFileDetector","k","input","prompt","validateInput","validatePositiveIntegerInput","Number","wrapSync","makeQueueableCommand","queueSize","setPrintError","printErrorImpl","old","isRecording","isPlaying","getCurrentSequence","setShowInputBox","showInputBoxImpl","setShowMessage","showMessageImpl","WrapQueueSize","state","locked","queueable","queue","info","body","getQueueLength","onDetectTypingCallback","suspending","cursorMotionDetector","notifyDetectedTyping","detectTyping","text0","every","chg","isUniformTextInsert","isEqual","replacesCorrespondingSelection","prediction","rangeLength","sameLine","uniformDeletingLength","isInsertingWithDeleting","uniformPairedText","isBracketCompletionWithSelection","sels","offset","makePredictionOnBracketCompletion","contentChanges","sort","rangeOffset","sortContentChanges","selections1","selections2","sel1","anchor","compareTo","v","sortedChanges","lineOffset","lastLine","characterOffset","numLF","ch","lenLastLine","lastIndexOf","newPos","test","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}